<!doctype html><html lang=fr-fr>
<head>
<title>Systemd - partie 2 | Yet another tech blog</title>
<meta charset=utf-8>
<meta name=language content="fr">
<meta name=description content="A l'intérieur de systemd">
<meta name=keywords content="linux ,systemd ,init system">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Systemd - partie 2">
<meta name=twitter:description content="A l&amp;#39;intérieur de systemd">
<meta name=twitter:site content="https://twitter.com/CyrilleSondag">
<meta name=twitter:creator content="https://twitter.com/CyrilleSondag">
<link rel="shortcut icon" type=image/png href=/favicon.ico>
<link type=text/css rel=stylesheet href=/css/post.min.86d1effd4c412b85ac13db53a90c473a0f256f789b821e131125c9aa25cb6a6d.css integrity="sha256-htHv/UxBK4WsE9tTqQxHOg8lb3ibgh4TESXJqiXLam0=">
<link type=text/css rel=stylesheet href=/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=">
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/cyrillesondag.github.io\/"},"articleSection":"blog","name":"Systemd - partie 2","headline":"Systemd - partie 2","description":"A l\u0027intérieur de systemd","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2022","datePublished":"2022-02-06 23:24:56 \u002b0200 \u002b0200","dateModified":"2022-02-06 23:24:56 \u002b0200 \u002b0200","url":"https:\/\/cyrillesondag.github.io\/blog\/systemd-part-two\/","wordCount":"1974","keywords":["linux","systemd","init system","Blog"]}</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8KHJGZJ8WJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-8KHJGZJ8WJ',{anonymize_ip:!1})}</script>
</head>
<body>
<div class=burger__container>
<div class=burger aria-controls=navigation aria-label=Menu>
<div class="burger__meat burger__meat--1"></div>
<div class="burger__meat burger__meat--2"></div>
<div class="burger__meat burger__meat--3"></div>
</div>
</div>
<nav class=nav id=navigation>
<ul class=nav__list>
<li>
<a href=/>about</a>
</li>
<li>
<a class=active href=/blog>blog</a>
</li>
</ul>
</nav>
<main>
<div class=flex-wrapper>
<div class=post__container>
<div class=post>
<header class=post__header>
<h1 id=post__title>Systemd - partie 2</h1>
<time datetime="2022-02-06 23:24:56 +0200 +0200" class=post__date>Feb 6 2022</time>
</header>
<article class=post__content>
<figure><a href=Gustave_Caillebotte_-_Perissoires_sur_yerres.jpg>
<img sizes="(min-width: 35em) 1200px, 100vw" srcset="https://cyrillesondag.github.io/blog/systemd-part-two/Gustave_Caillebotte_-_Perissoires_sur_yerres_hu10ef75ea3012e1555995dd3a0ce4636f_104024_480x0_resize_q75_box.jpg 480w," src=https://cyrillesondag.github.io/blog/systemd-part-two/Gustave_Caillebotte_-_Perissoires_sur_yerres.jpg alt="Gustave Caillebotte - Périssoires sur l&amp;rsquo;Yerres (1877), huile sur toile, 103 × 155 cm, Milwaukee (USA), Milwaukee Art Museum."> </a><figcaption style=font-size:80%;text-align:center>
<p>Gustave Caillebotte - Périssoires sur l&rsquo;Yerres (1877), huile sur toile, 103 × 155 cm, Milwaukee (USA), Milwaukee Art Museum.</p>
</figcaption>
</figure>
<p><br>
Nous avons vu dans le précédent article quelques différences entre SysV init et systemd, ainsi que le mécanisme d&rsquo;initialisation de l&rsquo;espace utilisateur par le kernel.
Dans cet article, je vais aborder plus en détail sur le fonctionnement de systemd.</p>
<h2 id=les-managers>Les Managers<a class=anchor href=#les-managers>#</a></h2>
<p>L&rsquo;objet <em>manager</em> est central, il contient les valeurs par default des différentes propriétés du système et est responsable de la gestion des <em>units</em> qui lui sont attachées.
C&rsquo;est avec lui que les &ldquo;utilisateurs&rdquo; vont communiquer.</p>
<p>Il est chargé de propager les actions appelées job (par exemple : start, stop, reload&mldr;.) vers les <em>units</em> et d&rsquo;interagir avec les éléments tiers du système (watchdog, inotify, D-bus, cgroups&mldr;.).</p>
<p>Il en existe sous 2 formes ayant chacune des portés différentes :</p>
<p>La première (celui par défaut) appelé &ldquo;system&rdquo; est unique par machine et est normalement lancé par le process d&rsquo;init avec les droits root.</p>
<p>On peut vérifier que systemd est bien l&rsquo;init <em>manager</em> du système de la facon suivante :</p>
<pre><code class=language-shell># ls -ls /usr/sbin/init
/usr/sbin/init -&gt; /lib/systemd/systemd
</code></pre>
<p>Ou plus simplement utiliser cette commande :</p>
<pre><code class=language-shell>systemctl
</code></pre>
<p>La seconde est &ldquo;user&rdquo;, il est unique par utilisateur et hérite des mêmes droits que ce dernier.
Ce type d&rsquo;instance s&rsquo;avère particulièrement utile pour limiter les droits des services qui lui sont associés (rootless).</p>
<p>Pour connaitre l&rsquo;état d&rsquo;une instance utilisateur on peut utiliser la commande suivante :</p>
<pre><code class=language-shell>systemctl --user
</code></pre>
<p>Bien spécifier l&rsquo;argument <code>--user</code> devant toutes les commandes pour interagir avec l&rsquo;instance de l&rsquo;utilisateur.</p>
<h3 id=la-gestion-des-units>La gestion des Units<a class=anchor href=#la-gestion-des-units>#</a></h3>
<p>On l&rsquo;a vu les <em>managers</em> sont responsables de la gestion des <em>units</em>.</p>
<p>Une <em>unit</em> chargée par un <em>manager</em> elle est unique si son nom est unique (pour les templates, les alias, les fragments, le nom est résolu au runtime).</p>
<p>Les <em>units files</em> sont lues au premier &ldquo;référencement&rdquo; (par exemple lors de leur activation, ou bien via de liens de dépendances&mldr;), transformées en <em>unit</em> et mise en cache dans la mémoire du <em>manager</em> qui leur est associé.</p>
<p>Elles sont stockées à l&rsquo;intérieur d&rsquo;une HashMap sous la forme nom/valeur (d&rsquo;où leur unicité).</p>
<p>Pour cette raison, il faut forcer le ramasse-miette (GC) ce qui a pour effet de sérialiser sur disque l&rsquo;état des <em>units</em> actives, vider le cache du manager et recharger la configuration des <em>units</em> via leurs <em>unit file</em> (ce n&rsquo;est pas néanmoins pas toujours nécessaire, mais ça évite des erreurs).</p>
<p>Pour forcer le ramasse miette on utilise la commande suivante :</p>
<pre><code class=language-shell>systemctl daemon-reload
</code></pre>
<h3 id=arborescence-et-précédence>Arborescence et précédence<a class=anchor href=#arborescence-et-précédence>#</a></h3>
<p>La definition des <em>unit files</em> répondent a une précédence tres precise utilisé afin de faciliter l&rsquo;administration du système et sa mise à jour.</p>
<p>Par ordre d&rsquo;importance croissante (non exhaustif) en mode &ldquo;&ndash;system&rdquo; :</p>
<ul>
<li><code>/lib/systemd/system/*</code> : installés par le gestionnaire de paquets (il est recommandé d&rsquo;éviter de les modifier sous peine de pertes lors des mises à jour du paquet)</li>
<li><code>/usr/local/lib/systemd/system/*</code> : gérés par l&rsquo;administrateur</li>
<li><code>/run/systemd/system/*</code> : générées au runtime</li>
<li><code>/etc/systemd/system/*</code> : gérés par l&rsquo;administrateur</li>
</ul>
<p>Ainsi une <em>unit file</em> définie dans le répertoire <code>/etc/systemd/system/*</code> sera prioritaire sur celle définie dans <code>/lib/systemd/system/*</code></p>
<p>En mode &ldquo;&ndash;user&rdquo; la hiérarchie est un peu différente :</p>
<ul>
<li><code>/lib/systemd/user/*</code> : installés par le gestionnaire de paquets (ne doivent pas être modifiés sous peine de pertes lors des mises à jour)</li>
<li><code>/usr/local/lib/systemd/user/*</code> : gérés par l&rsquo;administrateur</li>
<li><code>/run/systemd/user/*</code> : générées au runtime</li>
<li><code>/etc/systemd/user/*</code> : gérés par l&rsquo;administrateur</li>
<li><code>~/.config/systemd/user/*</code> : géré par l&rsquo;utilisateur</li>
</ul>
<p>Ça peut paraitre compliqué aux premiers abords, mais limite le périmètre des différents intervenants sur une machine (utilisateurs, administrateurs, packageurs&mldr;) pour qu&rsquo;ils ne se marchent sur les pieds.</p>
<p>De plus des outils spécifiques sont fournis (on le verra plus loin) pour aider à la compréhension de ce mécanisme.</p>
<h3 id=fragment-configuration>Fragment Configuration<a class=anchor href=#fragment-configuration>#</a></h3>
<p>Les fragments configuration sont des fichiers qui permettent de modifier les propriétés d&rsquo;une ou d&rsquo;un groupe de <em>units</em> sans avoir à la/les redéfinir entièrement.
Ces fichiers répondent aux mêmes ordres de précédence que nous venons d&rsquo;aborder plus haut.</p>
<p>Pour surcharger, il est possible de définir des fichiers <code>.conf</code> qui seront lus par ordre alphabétique dans les formats suivants :</p>
<ul>
<li>Par type de <em>unit</em> sous la forme <code>&lt;unit_type>.d/*.conf</code>. Ainsi un fragment dans un répertoire <code>service.d/*.conf</code> s&rsquo;appliquera à tous les <code>*.service</code></li>
<li>Une <em>unit</em> spécifique sous la forme <code>&lt;unit_name>.d/*.conf</code></li>
<li>Ou grâce à une pseudo hiérarchie et l&rsquo;utilisation du signe &lsquo;-&rsquo; dans le nom des <em>units</em>. Ainsi un fragment de configuration dans le répertoire <code>foo-.d/*.conf</code> va surcharger les configurations des <em>units</em> <code>foo-bar.service</code>, <code>foo-foo.service</code> et <code>foo-bar-foo.service</code>&mldr;</li>
</ul>
<p>Voyons maintenant comment appliquer cela et les outils fournis par systemd pour nous assister dans la mise en place.</p>
<p>Si l&rsquo;on crée le fichier <code>/etc/systemd/system/service1.service</code> de la facon suivante :</p>
<pre><code class=language-ini>[Service]
Type=oneshot
ExecStart=/bin/echo hello world
</code></pre>
<p>Puis le fragment de configuration dans le fichier suivant <code>/etc/systemd/system/service1.service.d/00-override.conf</code> :</p>
<pre><code class=language-ini>[Service]
ExecStart=/bin/echo running this first
</code></pre>
<p>Puis le fichier suivant <code>/etc/systemd/system/service.d/00-override.conf</code> :</p>
<pre><code class=language-ini>[Service]
ExecStart=/bin/echo top level exec pre start
</code></pre>
<p>On obtient en utilisant la commande <code>systemctl cat</code> le détail de la configuration de la <em>unit</em> ainsi que ses différents fragments :</p>
<pre><code class=language-shell>$ systemctl cat service1.service
# /etc/systemd/system/service1.service
[Service]
ExecPreStart=/bin/echo hello world

# /etc/systemd/system/service1.service.d/00-override.conf
[Service]
ExecPreStart=/bin/echo running this first

# /etc/systemd/system/service.d/00-override.conf
[Service]
ExecPreStart=/bin/echo top level exec pre start
</code></pre>
<p>Et produit le résultat suivant :</p>
<pre><code>top level exec pre start
running this first
hello world
</code></pre>
<p>Il est intéressant de noter que les surcharges sont additives.
Pour passer outre les précédentes définitions, il faut d&rsquo;abord déclarer la propriété à vide avant de la surcharger avec la valeur attendue.</p>
<pre><code class=language-ini>[Service]
ExecStart=
ExecStart=/bin/echo top level exec pre start
</code></pre>
<h2 id=les-units>Les Units<a class=anchor href=#les-units>#</a></h2>
<p>Les <em>units</em> sont les éléments de bases de systemd.
Il existe 11 types différents de <em>unit</em>.
Ils correspondent chacun à un type d&rsquo;actions particulières.</p>
<p>Le type d&rsquo;une <em>unit</em> est déterminé par le suffix de son <em>unit file</em> :</p>
<ul>
<li>*.service : Qui permet de définir un groupe de processus. C&rsquo;est l&rsquo;objet qu&rsquo;on est le plus souvent amené à utiliser.</li>
<li>*.socket : Pour faire de l&rsquo;activation de services par sockets (IPC, network, unix socket&mldr;).</li>
<li>*.device : Pour prendre en compte l&rsquo;activation par périphériques via udev (dont le hot-plug).</li>
<li>*.mount : Pour gérer le montage de partitions.</li>
<li>*.automount : Qui permet le l&rsquo;activation des <em>units</em> .mount automatique lors du premier accès.</li>
<li>*.swap : Configuration d&rsquo;un point de montage swap</li>
<li>*.target : Sont des point de synchronisation d&rsquo;un ensemble de <em>units</em> (comme les run-levels de SysVinit), mais également des points de déclenchements.</li>
<li>*.path : Activation par observation de chemins</li>
<li>*.timer : Déclencheur périodique (à la manière de cron)</li>
<li>*.scope : Configuration d&rsquo;un ensemble de processus externes</li>
<li>*.slice : Qui permet de regrouper un ensemble de processus au sien d&rsquo;un cgroup commun.</li>
</ul>
<p>Une <em>unit</em> est décrite par une <em>unit file</em> qui est lu au premier référencement pour être transformé en <em>unit</em>.</p>
<p>L&rsquo;objet <em>units</em> implémentes les opérations de bases génériques, une spécialisation est faite via la structure <code>UnitVtable</code> qui va referencer les méthodes spécifiques à chaque type.</p>
<p>Voici un example non exhaustif des méthodes de <code>UnitVtable</code> :</p>
<pre><code class=language-c>typedef struct UnitVTable {
        /* How much memory does an object of this unit type need */
        size_t object_size;

        /* The name of the configuration file section with the private settings of this unit */
        const char *private_section;

        /* Config file sections this unit type understands, separated
         * by NUL chars */
        const char *sections;

        /* This should reset all type-specific variables. This should
         * not allocate memory, and is called with zero-initialized
         * data. It should hence only initialize variables that need
         * to be set != 0. */
        void (*init)(Unit *u);

        /* This should free all type-specific variables. It should be
         * idempotent. */
        void (*done)(Unit *u);

        /* Actually load data from disk. This may fail, and should set
         * load_state to UNIT_LOADED, UNIT_MERGED or leave it at
         * UNIT_STUB if no configuration could be found. */
        int (*load)(Unit *u);

        void (*dump)(Unit *u, FILE *f, const char *prefix);

        int (*start)(Unit *u);
        int (*stop)(Unit *u);
        int (*reload)(Unit *u);

        int (*kill)(Unit *u, KillWho w, int signo, sd_bus_error *error);

        /* Boils down the more complex internal state of this unit to
         * a simpler one that the engine can understand */
        UnitActiveState (*active_state)(Unit *u);

        /* Return false when there is a reason to prevent this unit from being gc'ed
         * even though nothing references it and it isn't active in any way. */
        bool (*may_gc)(Unit *u);

        /* Return true when the unit is not controlled by the manager (e.g. extrinsic mounts). */
        bool (*is_extrinsic)(Unit *u);

        /* Returns the exit status to propagate in case of FailureAction=exit/SuccessAction=exit; usually returns the
         * exit code of the &quot;main&quot; process of the service or similar. */
        int (*exit_status)(Unit *u);
        .....
} UnitVTable;
</code></pre>
<p>On retrouve logiquement dans l&rsquo;objet Unit l&rsquo;ensemble des sous-types, qui permettra de propager les actions génériques vers leurs implementations.</p>
<pre><code class=language-c>const UnitVTable * const unit_vtable[_UNIT_TYPE_MAX] = {
        [UNIT_SERVICE] = &amp;service_vtable,
        [UNIT_SOCKET] = &amp;socket_vtable,
        [UNIT_TARGET] = &amp;target_vtable,
        [UNIT_DEVICE] = &amp;device_vtable,
        [UNIT_MOUNT] = &amp;mount_vtable,
        [UNIT_AUTOMOUNT] = &amp;automount_vtable,
        [UNIT_SWAP] = &amp;swap_vtable,
        [UNIT_TIMER] = &amp;timer_vtable,
        [UNIT_PATH] = &amp;path_vtable,
        [UNIT_SLICE] = &amp;slice_vtable,
        [UNIT_SCOPE] = &amp;scope_vtable,
};
</code></pre>
<p>Un <em>unit</em> a un cycle de vie, et donc un état. Les états de base sont les suivants :</p>
<ul>
<li>Active</li>
<li>Reloading</li>
<li>Inactive</li>
<li>Failed</li>
<li>Activating</li>
<li>Deactivating</li>
<li>Maintenance</li>
</ul>
<p>Cette liste d&rsquo;état peut être, elle aussi, enrichie pour répondre au cycle de vie spécifique d&rsquo;un type d'<em>unit</em>.</p>
<p>Par exemple pour une <em>unit</em> de type service on trouve cette liste d&rsquo;états qui font tous la correspondance avec les états de base.</p>
<pre><code class=language-c>static const UnitActiveState state_translation_table[_SERVICE_STATE_MAX] = {
        [SERVICE_DEAD] = UNIT_INACTIVE,
        [SERVICE_CONDITION] = UNIT_ACTIVATING,
        [SERVICE_START_PRE] = UNIT_ACTIVATING,
        [SERVICE_START] = UNIT_ACTIVATING,
        [SERVICE_START_POST] = UNIT_ACTIVATING,
        [SERVICE_RUNNING] = UNIT_ACTIVE,
        [SERVICE_EXITED] = UNIT_ACTIVE,
        [SERVICE_RELOAD] = UNIT_RELOADING,
        [SERVICE_STOP] = UNIT_DEACTIVATING,
        [SERVICE_STOP_WATCHDOG] = UNIT_DEACTIVATING,
        [SERVICE_STOP_SIGTERM] = UNIT_DEACTIVATING,
        [SERVICE_STOP_SIGKILL] = UNIT_DEACTIVATING,
        [SERVICE_STOP_POST] = UNIT_DEACTIVATING,
        [SERVICE_FINAL_WATCHDOG] = UNIT_DEACTIVATING,
        [SERVICE_FINAL_SIGTERM] = UNIT_DEACTIVATING,
        [SERVICE_FINAL_SIGKILL] = UNIT_DEACTIVATING,
        [SERVICE_FAILED] = UNIT_FAILED,
        [SERVICE_AUTO_RESTART] = UNIT_ACTIVATING,
        [SERVICE_CLEANING] = UNIT_MAINTENANCE,
};
</code></pre>
<h2 id=job-et-transaction>Job et Transaction<a class=anchor href=#job-et-transaction>#</a></h2>
<p>Tout changement d&rsquo;état d&rsquo;une <em>unit</em> se fait au travers d&rsquo;un Job.
Il existe plusieurs types de job :</p>
<ul>
<li>Start / Verify</li>
<li>Stop</li>
<li>Reload</li>
<li>Restart</li>
<li>Nop</li>
</ul>
<p>On trouve également d&rsquo;autres types de Job qui sont la combinaison des types précédents :
par exemple &ldquo;try-restart&rdquo; se transformera à l&rsquo;exécution en &ldquo;start&rdquo; ou &ldquo;nop&rdquo; si la <em>unit</em> n&rsquo;est pas activée ou en cours de rechargement.</p>
<p>Prenons l&rsquo;exemple de la <em>unit file</em> suivante :</p>
<pre><code class=language-ini>[Unit]
Wants=multi-users.target
...
</code></pre>
<p>La propriété <code>Wants=</code> a pour effet de créer une dépendance entre cette <em>unit</em> et la target <em>unit</em> &ldquo;multi-user.target&rdquo;.</p>
<p>NB : La plupart des relations peuvent être notée dans un sens ou dans l&rsquo;autre (<code>Before=</code>/ <code>After=</code>, <code>Require=</code>/<code>RequiredBy=</code>&mldr;)
On pourrait donc réaliser cette même dépendance a l&rsquo;aide de la propriété <code>WantedBy=</code> dans la target et cela aurait le même effet.</p>
<p>Cette dépendance va avoir pour effet de propager l&rsquo;activation de la target &ldquo;multi-user.target&rdquo; aux <em>unit</em> ayant une relation de type <code>Wants=</code> avec elle.</p>
<p>Lors de cette activation une transaction qui va contenir le job d&rsquo;activation de la target en elle meme plus autant de job que de dépendances.</p>
<p>Ainsi dans le cas d&rsquo;une relation avec une <em>unit</em> de type <code>Wants=</code> la transaction pourra est mise ne succès même si ce job est en échec.
Ce qui n&rsquo;aurait pas été le cas avec une relation plus &ldquo;forte&rdquo; (par exemple <code>Require=</code>/<code>RequiredBy=</code>).</p>
<p>En pratique ces relations sont spécifiées par une enumeration de propriétés beaucoup plus fines les <code>UnitDependencyAtom</code> ou &ldquo;atoms&rdquo; (qui ne sont rien d&rsquo;autre qu&rsquo;un bitmask).</p>
<p>Ainsi la propriété <code>Wants=</code> est composée de la sorte :</p>
<pre><code class=language-c>[UNIT_WANTS] = UNIT_ATOM_PULL_IN_START_IGNORED |
               UNIT_ATOM_RETROACTIVE_START_FAIL |
               UNIT_ATOM_ADD_STOP_WHEN_UNNEEDED_QUEUE |
               UNIT_ATOM_ADD_DEFAULT_TARGET_DEPENDENCY_QUEUE,
</code></pre>
<p>Cela lui permet de réagir aux propriétés suivantes qui peuvent être utilisées par different objects (transaction, units&mldr;).
Sans rentrer dans les details on retrouve l&rsquo;attribut &ldquo;UNIT_ATOM_PULL_IN_START_IGNORED&rdquo; le comportement décrit plus haut.</p>
<p>Il implémente un mécanisme de transaction connu sous le nom de Job qui s&rsquo;assure de la transition d&rsquo;une <em>unit</em> d&rsquo;un état A vers un état B (par exemple start / stop / restart&mldr;).</p>
<h2 id=conclusion>Conclusion<a class=anchor href=#conclusion>#</a></h2>
<p>Vous l&rsquo;avez peut-être remarqué, mais systemd est concu comme un système orienté objet.
On retrouve d&rsquo;ailleurs beaucoup de principes de la POO (polymorphisme, sous-typage, redefinition&mldr;) dans les différents points que j&rsquo;ai abordés</p>
<p>Voilà ainsi va se conclure cet article.
Dans le prochain, nous aborderons l&rsquo;architecture de systemd.</p>
</article>
<ul class=tags__list>
<li class=tag__item>
<a class=tag__link href=https://cyrillesondag.github.io/tags/linux/>linux</a>
</li>
<li class=tag__item>
<a class=tag__link href=https://cyrillesondag.github.io/tags/systemd/>systemd</a>
</li></ul>
<div class=pagination>
<a class=pagination__item href=https://cyrillesondag.github.io/blog/systemd-part-one/>
<span class=pagination__label>Previous Post</span>
<span class=pagination__title>Systemd - partie 1</span>
</a>
<a class=pagination__item href=https://cyrillesondag.github.io/blog/systemd-part-three/>
<span class=pagination__label>Next Post</span>
<span class=pagination__title>Systemd - partie 3</span>
</a>
</div>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//github-blog-tpysk8cw2i.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
<footer class=post__footer>
<div class=social-icons>
<a class=social-icons__link title=Twitter href=https://twitter.com/CyrilleSondag target=_blank rel="me noopener">
<div class=social-icons__icon style=background-image:url(https://cyrillesondag.github.io/svg/twitter.svg)></div>
</a>
<a class=social-icons__link title=GitHub href=https://github.com/cyrillesondag target=_blank rel="me noopener">
<div class=social-icons__icon style=background-image:url(https://cyrillesondag.github.io/svg/github.svg)></div>
</a>
<a class=social-icons__link title=Email href=mailto:cyrille.sondag@gmail.com target=_blank rel="me noopener">
<div class=social-icons__icon style=background-image:url(https://cyrillesondag.github.io/svg/email.svg)></div>
</a>
</div>
<p>© 2022</p>
</footer>
</div>
</div>
<div class=toc-container>
<nav id=TableOfContents>
<ul>
<li><a href=#les-managers>Les Managers</a>
<ul>
<li><a href=#la-gestion-des-units>La gestion des Units</a></li>
<li><a href=#arborescence-et-précédence>Arborescence et précédence</a></li>
<li><a href=#fragment-configuration>Fragment Configuration</a></li>
</ul>
</li>
<li><a href=#les-units>Les Units</a></li>
<li><a href=#job-et-transaction>Job et Transaction</a></li>
<li><a href=#conclusion>Conclusion</a></li>
</ul>
</nav>
</div>
</div>
</main>
<script src=/js/index.min.575dda8d49ee02639942c63564273e6da972ab531dda26a08800bdcb477cbd7f.js integrity="sha256-V13ajUnuAmOZQsY1ZCc+balyq1Md2iagiAC9y0d8vX8=" crossorigin=anonymous></script>
<script src=https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js data-autoloader-path=https://unpkg.com/prismjs@1.20.0/components/></script>
<script src=/js/table-of-contents.js></script>
</body>
</html>