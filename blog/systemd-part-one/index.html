<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Systemd - partie 1 | Yet another tech blog</title><meta name=keywords content="linux,systemd,init system"><meta name=description content="Init system de initV a systemd"><meta name=author content="Cyrille Sondag"><link rel=canonical href=https://cyrillesondag.github.io/blog/systemd-part-one/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://cyrillesondag.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cyrillesondag.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cyrillesondag.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cyrillesondag.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cyrillesondag.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cyrillesondag.github.io/blog/systemd-part-one/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://cyrillesondag.github.io/blog/systemd-part-one/"><meta property="og:site_name" content="Yet another tech blog"><meta property="og:title" content="Systemd - partie 1"><meta property="og:description" content="Init system de initV a systemd"><meta property="og:locale" content="fr-fr"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-10-17T10:34:56+02:00"><meta property="article:modified_time" content="2025-12-02T17:43:25+01:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Systemd"><meta name=twitter:card content="summary"><meta name=twitter:title content="Systemd - partie 1"><meta name=twitter:description content="Init system de initV a systemd"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://cyrillesondag.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Systemd - partie 1","item":"https://cyrillesondag.github.io/blog/systemd-part-one/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Systemd - partie 1","name":"Systemd - partie 1","description":"Init system de initV a systemd","keywords":["linux","systemd","init system"],"articleBody":" Jean-Francois Millet - Les Glaneuses (1857), huile sur toile, 83,5 × 110 cm, Paris, musée d’Orsay.\nJe vais m’attacher dans cette partie introductive à expliciter la séquence de boot sous Linux pour m’arrêter au lancement du processus d’init. Puis faire la distinction entre systemd et SysV init sans rentrer dans les détails d’implémentation, puis revenir rapidement sur le débat autour de l’adoption du systemd.\nLes détails techniques et l’utilisation de systemd en lui-même feront les sujets d’articles suivants.\nHistorique Systemd a été développé à l’initiative de Lennard Poettering (la première version date de 2010 selon Wikipedia) comme étant le remplaçant - entre autres - de l’historique SysV init.\nPromu par Red Hat, il a fini par s’imposer comme un standard de l’industrie dans les distributions majeures Linux, malgré les critiques encore nombreuses.\nSystemd est la contraction de system daemon.\nDu boot à l’init Avant de parler de l’init il me semble important d’expliquer les étapes précédentes pour bien comprendre le contexte et le rôle de ce processus.\nDonc lors du démarrage, la séquence est la suivante :\nLe bootloader va sélectionner et lancer l’image du kernel au format bzImage (pour boot executable image), elle est située sur la partition de boot généralement sous le nom vmlinux.**.\nCette image est compilée et généralement assez minimale, c’est-à-dire qu’elle contient peu d’éléments statiques dans le but d’occuper un minimum d’espace disque et de faciliter son chargement et sa distribution. Grâce à cela une même image peut être utilisée par exemple aussi bien sur un téléphone portable que sur un serveur dernière génération (pourvu qu’ils utilisent la même architecture).\nPour réaliser le démarrage, il faut pouvoir accéder aux fichiers de configuration qui peuvent se trouver sur différents types de support : disque, partition, réseau… Pour y accéder, il est donc nécessaire de charger les différents modules/drivers correspondants.\nPour ce faire, il existe principalement deux méthodes :\nSoit pré-compiler dans l’image du kernel l’ensemble des drivers requis (mais sacrifier les avantages vus plus haut). Soit passer par une image temporaire contenant ce qui est nécessaire au démarrage du système. Parmi la multitude de tâches d’initialisations (vm, console, horloge…) que le kernel va réaliser, on va s’intéresser à quelques-unes en particulier.\nInstanciation du rootfs. Le rootfs est un filesystem un peu spécial, c’est la base de tous les futurs filesystems, il est stocké en mémoire et est présent dès les premières étapes du démarrage du kernel, ne peut être démonté bien qu’il soit rarement utilisé après la phase d’init.\nIl existe sous deux types :\nRAMFS qui est un simple “page cache” en mémoire dont aucun élément ne peut être persisté. TMPFS qui à l’inverse de RAMFS permet de limiter l’espace utilisé en mémoire et l’écriture sur la SWAP. Le choix de l’un ou l’autre se fait à la compilation du kernel.\nLa décompression de l’initrd L’image temporaire du rootFS évoquée plus haut s’appelle l’initrd (initial ram disk) en hommage à l’ancien fonctionnement (\u003c 2.6) qui émulait un périphérique disque. C’est une simple archive compressée d’un filesystem au format cpio (un gz “amélioré”). Elle a l’avantage d’être plus facilement manipulable que l’image kernel, car non compilée. Il n’est donc pas nécessaire d’avoir un gcc ou des headers installés pour la générer ou la modifier. Elle est d’ailleurs régulièrement mise à jour au cours de la vie du système (souvent par les package managers).\non peut facilement lister le contenu grâce à la commande lsinitramfs ou la mettre à jour via update-initramfs\nCette archive est aussi stockée dans la partition de boot et passée en paramètre au kernel via le paramètre initrd=, qui va l’extraire dans le rootFS.\nEnfin - et c’est là que le processus d’init à proprement parler commence - le kernel va appeler l’exécutable /init (ou l’exécutable spécifié via rdinit=) sur le rootFS.\nL’initrd a pour but d’inclure les différents drivers et de monter le root device spécifié par le paramètre root= dans le dossier /root. Ensuite, il va supprimer les autres fichiers du rootFS puis appeler la fonction pivot_root pour transformer le répertoire /root en / (à la manière d’un chroot). Bien souvent (c’est le cas de systemd) ce processus va ré-exécuter une autre phase d’init pour prendre en charge la suite de l’initialisation du système après le montage du root.\nLe montage “/root” En cas d’absence de l’initrd le kernel va appeler la méthode prepare_namespace (qui remplit le même contrat que l’exécutable /init) c’est-à-dire tenter de monter le périphérique spécifié par le paramètre root= dans le répertoire /root, puis faire basculer ce répertoire à la racine.\nEnfin il va appeler l’un des processus d’init suivants (/sbin/init, /etc/init, /bin/init, /bin/sh)\nmain.c ‘kernel_init()’\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 if (ramdisk_execute_command) { ret = run_init_process(ramdisk_execute_command); if (!ret) return 0; pr_err(\"Failed to execute %s (error %d)\\n\", ramdisk_execute_command, ret); } /* * We try each of these until one succeeds. * * The Bourne shell can be used instead of init if we are * trying to recover a really broken machine. */ if (execute_command) { ret = run_init_process(execute_command); if (!ret) return 0; panic(\"Requested init %s failed (error %d).\", execute_command, ret); } if (!try_to_run_init_process(\"/sbin/init\") || !try_to_run_init_process(\"/etc/init\") || !try_to_run_init_process(\"/bin/init\") || !try_to_run_init_process(\"/bin/sh\")) return 0; panic(\"No working init found. Try passing init= option to kernel. \" \"See Linux Documentation/admin-guide/init.rst for guidance.\"); L’init Comme c’est le premier processus lancé par le kernel, il porte donc logiquement le numéro PID=1.\nCe processus est un peu différent des autres :\nNe peut être tué. N’a pas de parent PPID=. Est l’ancêtre de tous les autres processus. Est chargé d’initialiser tout un nombre de ressources (disque, terminaux, réseau, interface graphique…). Sous linux les processus sont tous issus de la methode fork() ou dérivés.\nTous les processus enfants héritent d’un certain nombre d’attributs de leur parent : user, session, cgroup, mémoire partagé…\nL’init a donc un rôle primordial dans la vie du système.\nSysV init Pour bien comprendre ce que systemd apporte il faut le comparer à son prédécesseur SysV init (j’ai choisi initV uniquement parce que c’était le plus répandu et que je l’ai un peu utilisé).\nSysV init est basé sur les run-levels qui sont au nombre de 5 (presque) :\n0 - réservé - Arrêt (halt) 1 - Mode utilisateur unique avec les filesystems montés. 2..5 Mode multi-utilisateur, les significations varient suivant les distributions, mais correspondent à l’état opérationnel de la machine. 6 - réservé - Redémarrage Il faut d’ailleurs comprendre le nom SysV init comme étant “système 5 init” qui correspond aux 5 run-level de l’état d’un système.\nLors de l’init le système va passer d’un run-level à l’autre jusqu’à arriver au default level (qui peut varier suivant les distributions…) qui correspond au mode nominal de fonctionnement (par exemple une interface graphique pour un desktop ou un terminal pour un serveur).\nEn cas d’erreur du level X le level X+1 n’est pas appelé et l’initialisation est marquée en échec.\nChacun des levels agit comme un point de synchronisation, c’est-à-dire qu’il va déclencher un nombre d’actions à une étape précise du démarrage du système.\nPar exemple si un daemon “A” nécessite une interface réseau ou des filesystems locaux, il a tout intérêt à se déclencher à un run-level supérieur à 1.\nScripts SysV init SysV init est basé sur un ensemble de scripts, qui doivent répondre à des conventions, certaines peuvent varier suivant les distributions Linux utilisées.\nPrenons l’exemple très simple d’un script de lancement d’un daemon :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #!/bin/sh #(1) # # Demonstrate creating your own init scripts # chkconfig: 2345 91 64 (2) ### BEGIN INIT INFO (3) # Provides: Welcome # Required-Start: $local_fs $all # Required-Stop: # Default-Start: 2345 # Default-Stop: # Short-Description: Display a welcome message # Description: Just display a message. Not much else. ###END INIT INFO # Source function library. . /etc/rc.d/init.d/functions #(4) lock_file=/var/lock/subsys/myservice start() { touch \"$lock_file\" echo \"Starting service\" sleep 2 } case \"$1\" in #(5) start) start ;; stop) rm -f \"$lock_file\" echo \"Service is shutting down\" sleep 2 ;; status) if [[ -f \"$lock_file\" ]]; then echo \"Service looks good\" else echo \"Service not started !!\" fi ;; *) echo $\"Usage: $0 {start|stop|status}\" exit 5 esac exit $? #(6) Il est composé :\n(1) D’une déclaration de l’interpréteur (ici shell) Ensuite une série de commentaires qui n’en sont pas : (2) chkconfig qui permet de définir les levels d’exécution et le niveau de priorité (3) LSB Headers qui contient des informations sur ordonnancement du service qui peut être éventuellement utilisé (4) L’import des fonctions communes /etc/rc.d/init.d/functions (5) Un switch case en fonction des arguments ‘start’ / ‘stop’ / ‘status’ (6) Un code de retour PROS :\nOffre un nombre de fonctionnalités assez complètes : ckconfig, lsb-headers. Une grande flexibilité : c’est un script shell on fait ‘ce qu’on veut’. Un début de standardisation (avec les fonctions, lsb headers, checkconfig). CONS :\nTrès verbeux, répétitif et difficilement extensible. Repose uniquement sur des conventions (start, stop, status…). Compliqué à réaliser. Peut avoir des comportements différents selon le contexte d’appel du script. D’un point de vue utilisateur, on remarque bien que ce n’est pas standardisé (avec ses avantages et ses inconvénients) et en pratique demande pas mal d’expertise en script pour réaliser des choses assez semblables (gérer les sorties standards, changer d’utilisateur, lancer un daemon, exécution unique…)\nLà où SysV init se résume à séquencer l’exécution de scripts (en schématisant), systemd se base sur de la description de configuration.\nService unit systemd Ces configurations sont écrites au format ini et sont appelées “unit file” ou “unit” (mais ce n’est pas exact, car ça désigne les objets manipulés par systemd et non les fichiers).\nIl existe plusieurs types d’unit files qui répondent à différents cas d’utilisations (service, montage…), chacune est suffixée par son type.\nL’équivalent systemd du script ci-dessus est une unit file de type “service” que l’on pourrait adapter de la sorte :\n1 2 3 4 5 6 7 8 9 10 [Unit] Description=Service [Service] Type=simple ExecStart=/usr/bin/sleep 2 ExecPreStop=/usr/bin/sleep 2 [Install] Wants=multi-users.target La première chose que l’on remarque est que le fichier systemd n’est pas un script, il n’a donc pas d’utilité en dehors du contexte de systemd.\nDeuxième chose, les attributs de configuration sont normés, ils correspondent à une série de propriétés interprétées par le programme. Ce n’est plus nous qui réalisons les actions, c’est systemd qui le fait à notre place.\nLe script de base est extrêmement simple, et n’a pas vraiment de sens (encore moins avec systemd) mais met bien en évidence toutes les choses qui sont incluses de base dans systemd, et la différence entre les deux approches.\nL’avantage ici d’être dans un “framework” est qu’il prend nativement en charge toutes les tâches usuelles sans avoir à les redéfinir nous-mêmes.\nUn service est unique, pour un même nom (au sein d’une instance systemd). Nous n’avons donc pas besoin de lock de synchronisation (il est possible de le variabiliser via le templating). Les états start / status / stop / restart sont implicites et communs à tous les services. Il faut noter que le status a souvent une signification un peu différente des scripts initV qui réalisent souvent des tâches de vérification assez complexes. Sous systemd le status ne reporte généralement que l’état du PID déterminé comme principal. Là où l’on devait spécifier via les lsb-headers l’ordonnancement (after $local_fs) fait ici partie de la valeur par défaut (cf defaultdependencies) qui doit répondre à la majorité des cas d’utilisations des daemons de haut niveau. Enfin on retrouve un équivalent des run-level avec l’attribut Target=multi-users.target qui sert ici également de point de synchronisation lors du démarrage. Le mal aimé On a beaucoup reproché à systemd d’être envahissant, et de briser le principe “un programme doit faire UNE chose et la faire bien”.\nOui systemd est envahissant, mais principalement parce que c’est un init system, une des pièces principales des systèmes UNIX. Il est de ce fait chargé de réaliser une multitude d’actions très différentes (monter les fs, mettre en place les interfaces réseau…). Ce qui était “caché” sous des scripts est ici rendu apparent.\nLes défenseurs rétorquent souvent que systemd est modulaire - ce qui est vrai - mais cela ne me semble pas être un argument valable, les composants peuvent faire partie de différents projets/modules (journald, networkd, nspawn…) ils font tous partie d’un ensemble cohérent et ont tous vocation à fonctionner ensemble.\nÀ mon avis la principale résistance est que systemd a imposé ses standards (en termes de nomenclature, arborescence, packaging et autres) au sein des distributions.\nJ’y vois également la réaction à la professionnalisation inévitable de l’écosystème Linux, avec la disparition progressive de l’esprit pionnier qui perdure dans les communautés de passionnés organisées autour des distributions / projets OSS. (Il faut aussi bien avouer que la communauté Linux ADORE les dramas et trouver des occasions de s’écharper).\nSystemd n’est certainement pas idéal, mais il est “constant”. Il a indéniablement apporté beaucoup de bénéfices : facilitation du packaging, une meilleure portabilité, une qualité accrue et plus homogène, une facilité d’accès aux fonctions avancées du kernel…\nBref, il ne s’agit pas de défendre systemd mais bien de mettre en avant les bénéfices qu’il apporte.\n","wordCount":"2243","inLanguage":"en","datePublished":"2021-10-17T10:34:56+02:00","dateModified":"2025-12-02T17:43:25+01:00","author":{"@type":"Person","name":"Cyrille Sondag"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cyrillesondag.github.io/blog/systemd-part-one/"},"publisher":{"@type":"Organization","name":"Yet another tech blog","logo":{"@type":"ImageObject","url":"https://cyrillesondag.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cyrillesondag.github.io/ accesskey=h title="Yet another tech blog (Alt + H)">Yet another tech blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cyrillesondag.github.io/ title=Accueil><span>Accueil</span></a></li><li><a href=https://cyrillesondag.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://cyrillesondag.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cyrillesondag.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cyrillesondag.github.io/blog/>Blogs</a></div><h1 class="post-title entry-hint-parent">Systemd - partie 1</h1><div class=post-description>Init system de initV a systemd</div><div class=post-meta><span title='2021-10-17 10:34:56 +0200 +0200'>17 October 2021</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>Cyrille Sondag</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#historique aria-label=Historique>Historique</a></li><li><a href=#du-boot-%c3%a0-linit aria-label="Du boot à l&rsquo;init">Du boot à l&rsquo;init</a><ul><ul><li><a href=#instanciation-du-rootfs aria-label="Instanciation du rootfs.">Instanciation du rootfs.</a></li><li><a href=#la-d%c3%a9compression-de-linitrd aria-label="La décompression de l&rsquo;initrd">La décompression de l&rsquo;initrd</a></li><li><a href=#le-montage-root aria-label="Le montage &ldquo;/root&rdquo;">Le montage &ldquo;/root&rdquo;</a></li></ul></ul></li><li><a href=#linit aria-label=L&rsquo;init>L&rsquo;init</a></li><li><a href=#sysv-init aria-label="SysV init">SysV init</a></li><li><a href=#scripts-sysv-init aria-label="Scripts SysV init">Scripts SysV init</a></li><li><a href=#service-unit-systemd aria-label="Service unit systemd">Service unit systemd</a></li><li><a href=#le-mal-aim%c3%a9 aria-label="Le mal aimé">Le mal aimé</a></li></ul></div></details></div><div class=post-content><figure><a href=Jean-Fran%c3%a7ois_Millet_-_Gleaners_-_Google_Art_Project_2.jpg><img sizes="(min-width: 35em) 1200px, 100vw" srcset='https://cyrillesondag.github.io/blog/systemd-part-one/Jean-Fran%C3%A7ois_Millet_-_Gleaners_-_Google_Art_Project_2_hu_7a9ffdd23859508d.jpg 480w,
https://cyrillesondag.github.io/blog/systemd-part-one/Jean-Fran%C3%A7ois_Millet_-_Gleaners_-_Google_Art_Project_2_hu_e3eb97c187c6fdeb.jpg 800w,
https://cyrillesondag.github.io/blog/systemd-part-one/Jean-Fran%C3%A7ois_Millet_-_Gleaners_-_Google_Art_Project_2_hu_877d01c955c0e768.jpg 1200w,
https://cyrillesondag.github.io/blog/systemd-part-one/Jean-Fran%C3%A7ois_Millet_-_Gleaners_-_Google_Art_Project_2_hu_c67f72020effd2b9.jpg 1500w,' src=https://cyrillesondag.github.io/blog/systemd-part-one/Jean-Fran%C3%A7ois_Millet_-_Gleaners_-_Google_Art_Project_2_hu_e3eb97c187c6fdeb.jpg alt="Jean-Francois Millet - Les Glaneuses (1857), huile sur toile, 83,5 × 110 cm, Paris, musée d&rsquo;Orsay."></a><figcaption style=font-size:80%;text-align:center><p>Jean-Francois Millet - Les Glaneuses (1857), huile sur toile, 83,5 × 110 cm, Paris, musée d&rsquo;Orsay.</p></figcaption></figure><p>Je vais m&rsquo;attacher dans cette partie introductive à expliciter la séquence de boot sous Linux pour m&rsquo;arrêter au lancement du processus d&rsquo;init.
Puis faire la distinction entre systemd et SysV init sans rentrer dans les détails d&rsquo;implémentation, puis revenir rapidement sur le débat autour de l&rsquo;adoption du systemd.</p><p>Les détails techniques et l&rsquo;utilisation de systemd en lui-même feront les sujets d&rsquo;articles suivants.</p><h2 id=historique>Historique<a hidden class=anchor aria-hidden=true href=#historique>#</a></h2><p>Systemd a été développé à l&rsquo;initiative de Lennard Poettering (la première version date de 2010 selon Wikipedia) comme étant le remplaçant - entre autres - de l&rsquo;historique SysV init.</p><p>Promu par Red Hat, il a fini par s&rsquo;imposer comme un standard de l&rsquo;industrie dans les distributions majeures Linux, malgré les critiques encore nombreuses.</p><p>Systemd est la contraction de system daemon.</p><h2 id=du-boot-à-linit>Du boot à l&rsquo;init<a hidden class=anchor aria-hidden=true href=#du-boot-à-linit>#</a></h2><p>Avant de parler de l&rsquo;init il me semble important d&rsquo;expliquer les étapes précédentes pour bien comprendre le contexte et le rôle de ce processus.</p><p>Donc lors du démarrage, la séquence est la suivante :</p><p>Le bootloader va sélectionner et lancer l&rsquo;image du kernel au format bzImage (pour boot executable image), elle est située sur la partition de boot généralement sous le nom <code>vmlinux.**</code>.</p><p>Cette image est compilée et généralement assez minimale, c&rsquo;est-à-dire qu&rsquo;elle contient peu d&rsquo;éléments statiques dans le but d&rsquo;occuper un minimum d&rsquo;espace disque et de faciliter son chargement et sa distribution.
Grâce à cela une même image peut être utilisée par exemple aussi bien sur un téléphone portable que sur un serveur dernière génération (pourvu qu&rsquo;ils utilisent la même architecture).</p><p>Pour réaliser le démarrage, il faut pouvoir accéder aux fichiers de configuration qui peuvent se trouver sur différents types de support : disque, partition, réseau&mldr;
Pour y accéder, il est donc nécessaire de charger les différents modules/drivers correspondants.</p><p>Pour ce faire, il existe principalement deux méthodes :</p><ul><li>Soit pré-compiler dans l&rsquo;image du kernel l&rsquo;ensemble des drivers requis (mais sacrifier les avantages vus plus haut).</li><li>Soit passer par une image temporaire contenant ce qui est nécessaire au démarrage du système.</li></ul><p>Parmi la multitude de tâches d&rsquo;initialisations (vm, console, horloge&mldr;) que le kernel va réaliser, on va s&rsquo;intéresser à quelques-unes en particulier.</p><h4 id=instanciation-du-rootfs>Instanciation du rootfs.<a hidden class=anchor aria-hidden=true href=#instanciation-du-rootfs>#</a></h4><p>Le rootfs est un filesystem un peu spécial, c&rsquo;est la base de tous les futurs filesystems, il est stocké en mémoire et est présent dès les premières étapes du démarrage du kernel, ne peut être démonté bien qu&rsquo;il soit rarement utilisé après la phase d&rsquo;init.</p><p>Il existe sous deux types :</p><ul><li>RAMFS qui est un simple &ldquo;page cache&rdquo; en mémoire dont aucun élément ne peut être persisté.</li><li>TMPFS qui à l&rsquo;inverse de RAMFS permet de limiter l&rsquo;espace utilisé en mémoire et l&rsquo;écriture sur la SWAP.</li></ul><p>Le choix de l&rsquo;un ou l&rsquo;autre se fait à la compilation du kernel.</p><h4 id=la-décompression-de-linitrd>La décompression de l&rsquo;initrd<a hidden class=anchor aria-hidden=true href=#la-décompression-de-linitrd>#</a></h4><p>L&rsquo;image temporaire du rootFS évoquée plus haut s&rsquo;appelle l&rsquo;initrd (initial ram disk) en hommage à l&rsquo;ancien fonctionnement (&lt; 2.6) qui émulait un périphérique disque.
C&rsquo;est une simple archive compressée d&rsquo;un filesystem au format cpio (un gz &ldquo;amélioré&rdquo;).
Elle a l&rsquo;avantage d&rsquo;être plus facilement manipulable que l&rsquo;image kernel, car non compilée.
Il n&rsquo;est donc pas nécessaire d&rsquo;avoir un gcc ou des headers installés pour la générer ou la modifier.
Elle est d&rsquo;ailleurs régulièrement mise à jour au cours de la vie du système (souvent par les package managers).</p><blockquote><p>on peut facilement lister le contenu grâce à la commande <code>lsinitramfs</code> ou la mettre à jour via <code>update-initramfs</code></p></blockquote><p>Cette archive est aussi stockée dans la partition de boot et passée en paramètre au kernel via le paramètre <code>initrd=</code>, qui va l&rsquo;extraire dans le rootFS.</p><p>Enfin - et c&rsquo;est là que le processus d&rsquo;init à proprement parler commence - le kernel va appeler l&rsquo;exécutable <code>/init</code> (ou l&rsquo;exécutable spécifié via <code>rdinit=</code>) sur le rootFS.</p><p>L&rsquo;initrd a pour but d&rsquo;inclure les différents drivers et de monter le root device spécifié par le paramètre <code>root=</code> dans le dossier <code>/root</code>.
Ensuite, il va supprimer les autres fichiers du rootFS puis appeler la fonction <code>pivot_root</code> pour transformer le répertoire <code>/root</code> en <code>/</code> (à la manière d&rsquo;un chroot).
Bien souvent (c&rsquo;est le cas de systemd) ce processus va ré-exécuter une autre phase d&rsquo;init pour prendre en charge la suite de l&rsquo;initialisation du système après le montage du root.</p><h4 id=le-montage-root>Le montage &ldquo;/root&rdquo;<a hidden class=anchor aria-hidden=true href=#le-montage-root>#</a></h4><p>En cas d&rsquo;absence de l&rsquo;initrd le kernel va appeler la méthode <code>prepare_namespace</code> (qui remplit le même contrat que l&rsquo;exécutable <code>/init</code>) c&rsquo;est-à-dire tenter de monter le périphérique spécifié par le paramètre <code>root=</code> dans le répertoire <code>/root</code>, puis faire basculer ce répertoire à la racine.</p><p>Enfin il va appeler l&rsquo;un des processus d&rsquo;init suivants (<code>/sbin/init</code>, <code>/etc/init</code>, <code>/bin/init</code>, <code>/bin/sh</code>)</p><blockquote><p><em>main.c</em> &lsquo;kernel_init()&rsquo;</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>ramdisk_execute_command</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=nf>run_init_process</span><span class=p>(</span><span class=n>ramdisk_execute_command</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>pr_err</span><span class=p>(</span><span class=s>&#34;Failed to execute %s (error %d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=n>ramdisk_execute_command</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * We try each of these until one succeeds.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * The Bourne shell can be used instead of init if we are
</span></span></span><span class=line><span class=cl><span class=cm> * trying to recover a really broken machine.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>execute_command</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=nf>run_init_process</span><span class=p>(</span><span class=n>execute_command</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;Requested init %s failed (error %d).&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>execute_command</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/sbin/init&#34;</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>    <span class=o>!</span><span class=nf>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/etc/init&#34;</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>    <span class=o>!</span><span class=nf>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/bin/init&#34;</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>    <span class=o>!</span><span class=nf>try_to_run_init_process</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>panic</span><span class=p>(</span><span class=s>&#34;No working init found.  Try passing init= option to kernel. &#34;</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;See Linux Documentation/admin-guide/init.rst for guidance.&#34;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=linit>L&rsquo;init<a hidden class=anchor aria-hidden=true href=#linit>#</a></h2><p>Comme c&rsquo;est le premier processus lancé par le kernel, il porte donc logiquement le numéro <code>PID=1</code>.</p><p>Ce processus est un peu différent des autres :</p><ul><li>Ne peut être tué.</li><li>N&rsquo;a pas de parent <code>PPID=</code>.</li><li>Est l&rsquo;ancêtre de tous les autres processus.</li><li>Est chargé d&rsquo;initialiser tout un nombre de ressources (disque, terminaux, réseau, interface graphique…).</li></ul><blockquote><p>Sous linux les processus sont tous issus de la methode <code>fork()</code> ou dérivés.</p><p>Tous les processus enfants héritent d&rsquo;un certain nombre d&rsquo;attributs de leur parent : user, session, cgroup, mémoire partagé&mldr;</p><p>L&rsquo;init a donc un rôle primordial dans la vie du système.</p></blockquote><h2 id=sysv-init>SysV init<a hidden class=anchor aria-hidden=true href=#sysv-init>#</a></h2><p>Pour bien comprendre ce que systemd apporte il faut le comparer à son prédécesseur SysV init (j&rsquo;ai choisi initV uniquement parce que c&rsquo;était le plus répandu et que je l&rsquo;ai un peu utilisé).</p><p>SysV init est basé sur les run-levels qui sont au nombre de 5 (presque) :</p><ul><li>0 - réservé - Arrêt (halt)</li><li>1 - Mode utilisateur unique avec les filesystems montés.</li><li>2..5 Mode multi-utilisateur, les significations varient suivant les distributions, mais correspondent à l&rsquo;état opérationnel de la machine.</li><li>6 - réservé - Redémarrage</li></ul><p>Il faut d&rsquo;ailleurs comprendre le nom SysV init comme étant &ldquo;système 5 init&rdquo; qui correspond aux 5 run-level de l&rsquo;état d&rsquo;un système.</p><p>Lors de l&rsquo;init le système va passer d&rsquo;un run-level à l&rsquo;autre jusqu&rsquo;à arriver au <em><strong>default level</strong></em> (qui peut varier suivant les distributions&mldr;) qui correspond au mode nominal de fonctionnement (par exemple une interface graphique pour un desktop ou un terminal pour un serveur).</p><p>En cas d&rsquo;erreur du level X le level X+1 n&rsquo;est pas appelé et l&rsquo;initialisation est marquée en échec.</p><p>Chacun des levels agit comme un point de synchronisation, c&rsquo;est-à-dire qu&rsquo;il va déclencher un nombre d&rsquo;actions à une étape précise du démarrage du système.</p><blockquote><p>Par exemple si un daemon &ldquo;A&rdquo; nécessite une interface réseau ou des filesystems locaux, il a tout intérêt à se déclencher à un run-level supérieur à 1.</p></blockquote><h2 id=scripts-sysv-init>Scripts SysV init<a hidden class=anchor aria-hidden=true href=#scripts-sysv-init>#</a></h2><p>SysV init est basé sur un ensemble de scripts, qui doivent répondre à des conventions, certaines peuvent varier suivant les distributions Linux utilisées.</p><p>Prenons l&rsquo;exemple très simple d&rsquo;un script de lancement d&rsquo;un daemon :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/sh #(1)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1># </span>
</span></span><span class=line><span class=cl><span class=c1># Demonstrate creating your own init scripts </span>
</span></span><span class=line><span class=cl><span class=c1># chkconfig: 2345 91 64 (2) </span>
</span></span><span class=line><span class=cl><span class=c1>### BEGIN INIT INFO (3)</span>
</span></span><span class=line><span class=cl><span class=c1># Provides: Welcome </span>
</span></span><span class=line><span class=cl><span class=c1># Required-Start: $local_fs $all </span>
</span></span><span class=line><span class=cl><span class=c1># Required-Stop: </span>
</span></span><span class=line><span class=cl><span class=c1># Default-Start: 2345 </span>
</span></span><span class=line><span class=cl><span class=c1># Default-Stop: </span>
</span></span><span class=line><span class=cl><span class=c1># Short-Description: Display a welcome message </span>
</span></span><span class=line><span class=cl><span class=c1># Description: Just display a message. Not much else. </span>
</span></span><span class=line><span class=cl><span class=c1>###END INIT INFO </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Source function library. </span>
</span></span><span class=line><span class=cl>. /etc/rc.d/init.d/functions <span class=c1>#(4)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>lock_file</span><span class=o>=</span>/var/lock/subsys/myservice
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>start<span class=o>()</span>  <span class=o>{</span> 
</span></span><span class=line><span class=cl>   touch <span class=s2>&#34;</span><span class=nv>$lock_file</span><span class=s2>&#34;</span> 
</span></span><span class=line><span class=cl>   <span class=nb>echo</span> <span class=s2>&#34;Starting service&#34;</span> 
</span></span><span class=line><span class=cl>   sleep <span class=m>2</span>
</span></span><span class=line><span class=cl> <span class=o>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=s2>&#34;</span><span class=nv>$1</span><span class=s2>&#34;</span> in  <span class=c1>#(5)</span>
</span></span><span class=line><span class=cl>      start<span class=o>)</span> 
</span></span><span class=line><span class=cl>       start
</span></span><span class=line><span class=cl>        <span class=p>;;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      stop<span class=o>)</span>
</span></span><span class=line><span class=cl>       rm -f  <span class=s2>&#34;</span><span class=nv>$lock_file</span><span class=s2>&#34;</span> 
</span></span><span class=line><span class=cl>       <span class=nb>echo</span> <span class=s2>&#34;Service is shutting down&#34;</span>  
</span></span><span class=line><span class=cl>       sleep <span class=m>2</span> 
</span></span><span class=line><span class=cl>        <span class=p>;;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     status<span class=o>)</span>
</span></span><span class=line><span class=cl>       <span class=k>if</span> <span class=o>[[</span> -f <span class=s2>&#34;</span><span class=nv>$lock_file</span><span class=s2>&#34;</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>         <span class=nb>echo</span> <span class=s2>&#34;Service looks good&#34;</span>
</span></span><span class=line><span class=cl>       <span class=k>else</span>
</span></span><span class=line><span class=cl>         <span class=nb>echo</span> <span class=s2>&#34;Service not started !!&#34;</span>
</span></span><span class=line><span class=cl>       <span class=k>fi</span>
</span></span><span class=line><span class=cl>        <span class=p>;;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         *<span class=o>)</span>
</span></span><span class=line><span class=cl>       <span class=nb>echo</span> $<span class=s2>&#34;Usage: </span><span class=nv>$0</span><span class=s2> {start|stop|status}&#34;</span> 
</span></span><span class=line><span class=cl>       <span class=nb>exit</span> <span class=m>5</span> 
</span></span><span class=line><span class=cl><span class=k>esac</span> 
</span></span><span class=line><span class=cl><span class=nb>exit</span> <span class=nv>$?</span> <span class=c1>#(6)</span>
</span></span></code></pre></td></tr></table></div></div><p>Il est composé :</p><ul><li>(1) D&rsquo;une déclaration de l&rsquo;interpréteur (ici shell)</li><li>Ensuite une série de commentaires qui n&rsquo;en sont pas :<ul><li>(2) chkconfig qui permet de définir les levels d&rsquo;exécution et le niveau de priorité</li><li>(3) LSB Headers qui contient des informations sur ordonnancement du service qui peut être éventuellement utilisé</li></ul></li><li>(4) L&rsquo;import des fonctions communes /etc/rc.d/init.d/functions</li><li>(5) Un switch case en fonction des arguments &lsquo;start&rsquo; / &lsquo;stop&rsquo; / &lsquo;status&rsquo;</li><li>(6) Un code de retour</li></ul><p><em><strong>PROS</strong></em> :</p><ul><li>Offre un nombre de fonctionnalités assez complètes : ckconfig, lsb-headers.</li><li>Une grande flexibilité : c&rsquo;est un script shell on fait &lsquo;ce qu&rsquo;on veut&rsquo;.</li><li>Un début de standardisation (avec les fonctions, lsb headers, checkconfig).</li></ul><p><em><strong>CONS</strong></em> :</p><ul><li>Très verbeux, répétitif et difficilement extensible.</li><li>Repose uniquement sur des conventions (start, stop, status&mldr;).</li><li>Compliqué à réaliser.</li><li>Peut avoir des comportements différents selon le contexte d&rsquo;appel du script.</li></ul><p>D&rsquo;un point de vue utilisateur, on remarque bien que ce n&rsquo;est pas standardisé (avec ses avantages et ses inconvénients) et en pratique demande pas mal d&rsquo;expertise en script pour réaliser des choses assez semblables (gérer les sorties standards, changer d&rsquo;utilisateur, lancer un daemon, exécution unique&mldr;)</p><p>Là où SysV init se résume à séquencer l&rsquo;exécution de scripts (en schématisant), systemd se base sur de la description de configuration.</p><h2 id=service-unit-systemd>Service unit systemd<a hidden class=anchor aria-hidden=true href=#service-unit-systemd>#</a></h2><p>Ces configurations sont écrites au format ini et sont appelées &ldquo;unit file&rdquo; ou &ldquo;unit&rdquo; (mais ce n&rsquo;est pas exact, car ça désigne les objets manipulés par systemd et non les fichiers).</p><p>Il existe plusieurs types d&rsquo;unit files qui répondent à différents cas d&rsquo;utilisations (service, montage&mldr;), chacune est suffixée par son type.</p><p>L&rsquo;équivalent systemd du script ci-dessus est une unit file de type &ldquo;service&rdquo; que l&rsquo;on pourrait adapter de la sorte :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[Unit]</span>
</span></span><span class=line><span class=cl><span class=na>Description</span><span class=o>=</span><span class=s>Service</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=na>[Service] </span>
</span></span><span class=line><span class=cl><span class=na>Type</span><span class=o>=</span><span class=s>simple</span>
</span></span><span class=line><span class=cl><span class=na>ExecStart</span><span class=o>=</span><span class=s>/usr/bin/sleep 2</span>
</span></span><span class=line><span class=cl><span class=na>ExecPreStop</span><span class=o>=</span><span class=s>/usr/bin/sleep 2 </span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Install]</span>
</span></span><span class=line><span class=cl><span class=na>Wants</span><span class=o>=</span><span class=s>multi-users.target</span>
</span></span></code></pre></td></tr></table></div></div><p>La première chose que l&rsquo;on remarque est que le fichier systemd n&rsquo;est pas un script, il n&rsquo;a donc pas d&rsquo;utilité en dehors du contexte de systemd.</p><p>Deuxième chose, les attributs de configuration sont normés, ils correspondent à une série de propriétés interprétées par le programme.
Ce n&rsquo;est plus nous qui réalisons les actions, c&rsquo;est systemd qui le fait à notre place.</p><p>Le script de base est extrêmement simple, et n&rsquo;a pas vraiment de sens (encore moins avec systemd) mais met bien en évidence toutes les choses qui sont incluses de base dans systemd, et la différence entre les deux approches.</p><p>L&rsquo;avantage ici d&rsquo;être dans un &ldquo;framework&rdquo; est qu&rsquo;il prend nativement en charge toutes les tâches usuelles sans avoir à les redéfinir nous-mêmes.</p><ul><li>Un service est unique, pour un même nom (au sein d&rsquo;une instance systemd). Nous n&rsquo;avons donc pas besoin de lock de synchronisation (il est possible de le variabiliser via le templating).</li><li>Les états start / status / stop / restart sont implicites et communs à tous les services. Il faut noter que le status a souvent une signification un peu différente des scripts initV qui réalisent souvent des tâches de vérification assez complexes. Sous systemd le status ne reporte généralement que l&rsquo;état du <code>PID</code> déterminé comme principal.</li><li>Là où l&rsquo;on devait spécifier via les lsb-headers l&rsquo;ordonnancement (after $local_fs) fait ici partie de la valeur par défaut (cf <code>defaultdependencies</code>) qui doit répondre à la majorité des cas d&rsquo;utilisations des daemons de haut niveau.</li><li>Enfin on retrouve un équivalent des run-level avec l&rsquo;attribut <code>Target=multi-users.target</code> qui sert ici également de point de synchronisation lors du démarrage.</li></ul><h2 id=le-mal-aimé>Le mal aimé<a hidden class=anchor aria-hidden=true href=#le-mal-aimé>#</a></h2><p>On a beaucoup reproché à systemd d&rsquo;être envahissant, et de briser le principe &ldquo;un programme doit faire UNE chose et la faire bien&rdquo;.</p><p>Oui systemd est envahissant, mais principalement parce que c&rsquo;est un init system, une des pièces principales des systèmes UNIX. Il est de ce fait chargé de réaliser une multitude d&rsquo;actions très différentes (monter les fs, mettre en place les interfaces réseau&mldr;).
Ce qui était &ldquo;caché&rdquo; sous des scripts est ici rendu apparent.</p><p>Les défenseurs rétorquent souvent que systemd est modulaire - ce qui est vrai - mais cela ne me semble pas être un argument valable, les composants peuvent faire partie de différents projets/modules (journald, networkd, nspawn&mldr;) ils font tous partie d&rsquo;un ensemble cohérent et ont tous vocation à fonctionner ensemble.</p><p>À mon avis la principale résistance est que systemd a imposé ses standards (en termes de nomenclature, arborescence, packaging et autres) au sein des distributions.</p><p>J&rsquo;y vois également la réaction à la professionnalisation inévitable de l&rsquo;écosystème Linux, avec la disparition progressive de l&rsquo;esprit pionnier qui perdure dans les communautés de passionnés organisées autour des distributions / projets OSS.
(Il faut aussi bien avouer que la communauté Linux ADORE les dramas et trouver des occasions de s&rsquo;écharper).</p><p>Systemd n&rsquo;est certainement pas idéal, mais il est &ldquo;constant&rdquo;.
Il a indéniablement apporté beaucoup de bénéfices : facilitation du packaging, une meilleure portabilité, une qualité accrue et plus homogène, une facilité d&rsquo;accès aux fonctions avancées du kernel&mldr;</p><p>Bref, il ne s&rsquo;agit pas de défendre systemd mais bien de mettre en avant les bénéfices qu&rsquo;il apporte.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cyrillesondag.github.io/tags/linux/>Linux</a></li><li><a href=https://cyrillesondag.github.io/tags/systemd/>Systemd</a></li></ul><nav class=paginav><a class=prev href=https://cyrillesondag.github.io/blog/systemd-part-two/><span class=title>« Prev</span><br><span>Systemd - partie 2</span>
</a><a class=next href=https://cyrillesondag.github.io/blog/presentation-linux-menory/><span class=title>Next »</span><br><span>Présentation Linux Memory</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 1 on x" href="https://x.com/intent/tweet/?text=Systemd%20-%20partie%201&amp;url=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-one%2f&amp;hashtags=linux%2csystemd"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 1 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-one%2f&amp;title=Systemd%20-%20partie%201&amp;summary=Systemd%20-%20partie%201&amp;source=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-one%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 1 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-one%2f&title=Systemd%20-%20partie%201"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 1 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-one%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 1 on whatsapp" href="https://api.whatsapp.com/send?text=Systemd%20-%20partie%201%20-%20https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-one%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 1 on telegram" href="https://telegram.me/share/url?text=Systemd%20-%20partie%201&amp;url=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-one%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 1 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Systemd%20-%20partie%201&u=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-one%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>© {year}</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>