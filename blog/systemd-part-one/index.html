<!doctype html><html lang=fr-fr>
<head>
<title>Systemd - partie 1 | Yet another tech blog</title>
<meta charset=utf-8>
<meta name=language content="fr">
<meta name=description content="Init system de initV a systemd">
<meta name=keywords content="linux ,systemd ,init system">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Systemd - partie 1">
<meta name=twitter:description content="Init system de initV a systemd">
<meta name=twitter:site content="https://twitter.com/CyrilleSondag">
<meta name=twitter:creator content="https://twitter.com/CyrilleSondag">
<link rel="shortcut icon" type=image/png href=/favicon.ico>
<link type=text/css rel=stylesheet href=/css/post.min.86d1effd4c412b85ac13db53a90c473a0f256f789b821e131125c9aa25cb6a6d.css integrity="sha256-htHv/UxBK4WsE9tTqQxHOg8lb3ibgh4TESXJqiXLam0=">
<link type=text/css rel=stylesheet href=/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=">
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/cyrillesondag.github.io\/"},"articleSection":"blog","name":"Systemd - partie 1","headline":"Systemd - partie 1","description":"Init system de initV a systemd","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2021","datePublished":"2021-10-17 10:34:56 \u002b0200 \u002b0200","dateModified":"2021-10-17 10:34:56 \u002b0200 \u002b0200","url":"https:\/\/cyrillesondag.github.io\/blog\/systemd-part-one\/","wordCount":"2156","keywords":["linux","systemd","init system","Blog"]}</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8KHJGZJ8WJ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-8KHJGZJ8WJ',{anonymize_ip:!1})}</script>
</head>
<body>
<div class=burger__container>
<div class=burger aria-controls=navigation aria-label=Menu>
<div class="burger__meat burger__meat--1"></div>
<div class="burger__meat burger__meat--2"></div>
<div class="burger__meat burger__meat--3"></div>
</div>
</div>
<nav class=nav id=navigation>
<ul class=nav__list>
<li>
<a href=/>about</a>
</li>
<li>
<a class=active href=/blog>blog</a>
</li>
</ul>
</nav>
<main>
<div class=flex-wrapper>
<div class=post__container>
<div class=post>
<header class=post__header>
<h1 id=post__title>Systemd - partie 1</h1>
<time datetime="2021-10-17 10:34:56 +0200 +0200" class=post__date>Oct 17 2021</time>
</header>
<article class=post__content>
<figure><a href=Jean-Fran%c3%a7ois_Millet_-_Gleaners_-_Google_Art_Project_2.jpg>
<img sizes="(min-width: 35em) 1200px, 100vw" srcset="https://cyrillesondag.github.io/blog/systemd-part-one/_hu5c4f97d8cc5442bd9a9cf546a5758978_16044388_fe2811953c321ed690b68cbeddf54f42.jpg 480w,
https://cyrillesondag.github.io/blog/systemd-part-one/_hu5c4f97d8cc5442bd9a9cf546a5758978_16044388_c5c3be34a57b1650073f7376d86f11bb.jpg 800w,
https://cyrillesondag.github.io/blog/systemd-part-one/_hu5c4f97d8cc5442bd9a9cf546a5758978_16044388_25c99d9897981114932b8cb48cf73897.jpg 1200w,
https://cyrillesondag.github.io/blog/systemd-part-one/_hu5c4f97d8cc5442bd9a9cf546a5758978_16044388_aa786fa022f9ee8c98e22467e495cdaa.jpg 1500w," src=https://cyrillesondag.github.io/blog/systemd-part-one/_hu5c4f97d8cc5442bd9a9cf546a5758978_16044388_c5c3be34a57b1650073f7376d86f11bb.jpg alt="Jean-Francois Millet - Les Glaneuses (1857), huile sur toile, 83,5 × 110 cm, Paris, musée d&amp;rsquo;Orsay."> </a><figcaption style=font-size:80%;text-align:center>
<p>Jean-Francois Millet - Les Glaneuses (1857), huile sur toile, 83,5 × 110 cm, Paris, musée d&rsquo;Orsay.</p>
</figcaption>
</figure>
<p>Je vais m&rsquo;attacher dans cette partie introductive à expliciter la séquence de boot sous Linux pour m&rsquo;arrêter au lancement du processus d&rsquo;init.
Puis faire la distinction entre systemd et SysV init sans rentrer dans les détails d&rsquo;implémentation, puis revenir rapidement sur le débat autour de l&rsquo;adoption du systemd.</p>
<p>Les détails techniques et l&rsquo;utilisation de systemd en lui-même feront les sujets d&rsquo;articles suivants.</p>
<h2 id=historique>Historique<a class=anchor href=#historique>#</a></h2>
<p>Systemd a été développé à l&rsquo;initiative de Lennard Poettering (la première version date de 2010 selon Wikipedia) comme étant le remplaçant - entre autres - de l&rsquo;historique SysV init.</p>
<p>Promu par Redhat, il a fini par s&rsquo;imposer comme un standard de l&rsquo;industrie dans les distributions majeures Linux, malgré les critiques encore nombreuses.</p>
<p>Systemd est la contraction de system daemon.</p>
<h2 id=du-boot-à-linit>Du boot à l&rsquo;init<a class=anchor href=#du-boot-à-linit>#</a></h2>
<p>Avant de parler de l&rsquo;init il me semble important d&rsquo;expliquer les étapes précédentes pour bien comprendre le contexte et le rôle de ce processus.</p>
<p>Donc lors du démarrage, la séquence est la suivante :</p>
<p>Le bootloader va sélectionner et lancer l&rsquo;image du kernel au format bzImage (pour boot executable image), elle est située sur la partition de boot généralement sous le nom <code>vmlinux.**</code>.</p>
<p>Cette image est compilée et généralement assez minimale, c&rsquo;est-à-dire qu&rsquo;elle contient peu d&rsquo;éléments statiques dans le but d&rsquo;occuper un minimum d&rsquo;espace disque et de faciliter son chargement et sa distribution.
Grâce à cela une même image peut être utilisée par exemple aussi bien sur un téléphone portable que sur un serveur dernière génération (pourvu qu&rsquo;ils utilisent la même architecture).</p>
<p>Pour réaliser le démarrage, il faut pouvoir accéder aux fichiers de configuration qui peuvent se trouver sur différents types de support : disque, partition, réseaux&mldr;
Pour y accéder il est donc nécessaire de charger les différents modules / drivers correspondants.</p>
<p>Pour ce faire il existe principalement deux méthodes :</p>
<ul>
<li>Soit pré-compiler dans l&rsquo;image du kernel l&rsquo;ensemble des drivers requis (mais sacrifier les avantages vus plus haut).</li>
<li>Soit passer par une image temporaire contenant ce qui est nécessaire au démarrage du système.</li>
</ul>
<p>Parmi la multitude de tâches d&rsquo;initialisations (vm, console, horloge&mldr;) que le kernel va réaliser, on va s&rsquo;intéresser à quelques-unes en particulier.</p>
<h4 id=instanciation-du-rootfs>Instanciation du rootfs.</h4>
<p>Le rootfs est un filesystem un peu spécial, c&rsquo;est la base de tous les futurs filesysteme, il est stocké en mémoire et est présent dès les premières étapes du démarrage du kernel, ne peut être démonté bien qu&rsquo;il soit rarement utilisé après la phase d&rsquo;init.</p>
<p>Il existe sous deux types :</p>
<ul>
<li>RAMFS qui est un simple &ldquo;page cache&rdquo; en mémoire dont aucun élément ne peut être persisté.</li>
<li>TMPFS qui à l&rsquo;inverse de RAMFS permet de limiter l&rsquo;espace utilisé en mémoire et l&rsquo;écriture sur la SWAP.</li>
</ul>
<p>Le choix de l&rsquo;un ou l&rsquo;autre se fait à la compilation du kernel.</p>
<h4 id=la-décompression-de-linitrd>La décompression de l&rsquo;initrd</h4>
<p>L&rsquo;image temporaire du rootFS évoquée plus haut s&rsquo;appelle l&rsquo;initrd (initial ram disk) en hommage à l&rsquo;ancien fonctionnement (&lt; 2.6) qui émulait un périphérique disque.
C&rsquo;est une simple archive compressée d&rsquo;un filesystem au format cpio (un gz &ldquo;amélioré&rdquo;).
Elle a l&rsquo;avantage d&rsquo;être plus facilement manipulable que l&rsquo;image kernel, car non compilée.
Il n&rsquo;est donc pas nécessaire d&rsquo;avoir un gcc ou des headers installés pour la générer ou la modifier.
Elle est d&rsquo;ailleurs régulièrement mise à jour au cours de la vie du système (souvent par les packages manager).</p>
<blockquote>
<p>on peut facilement lister le contenu grace a la commande <code>lsinitramfs</code> ou la mettre à jour via <code>update-initramfs</code></p>
</blockquote>
<p>Cette archive est aussi stockée dans la partition de boot et passée en paramètre au kernel via le paramètre <code>initrd=</code>, qui va l&rsquo;extraire dans le rootFS.</p>
<p>Enfin - et c&rsquo;est là que process d&rsquo;init à proprement parler commence - le kernel va appeler l&rsquo;exécutable <code>/init</code> (ou l&rsquo;exécutable spécifié via <code>rdinit=</code>) sur le rootFS.</p>
<p>L&rsquo;initrd a pour but d&rsquo;inclure les différents drivers et de monter le root device spécifié par le paramètre <code>root=</code> dans le dossier <code>/root</code>.
Ensuite, il va supprimer les autres fichiers du rootFS puis appeler la fonction <code>pivot_root</code> pour transformer le repertoire <code>/root</code> en <code>/</code> (à la manière d&rsquo;un chroot).
Bien souvent (c&rsquo;est le cas de systemd) ce process va re-exécuter une autre phase d&rsquo;init pour prendre en charge la suite de l&rsquo;initialisation du système après le montage du root.</p>
<h4 id=le-montage-root>Le montage &ldquo;/root&rdquo;</h4>
<p>En cas d&rsquo;absence de l&rsquo;initrd le kernel va appeler la méthode <code>prepare_namespace</code>(qui rempli le même contract que l&rsquo;exécutable <code>/init</code>) c&rsquo;est-a-dire tenter le monter le périphérique spécifié par le paramètre <code>root=</code> dans le répertoire <code>/root</code>, puis faire basculer ce répertoire à la racine.</p>
<p>Enfin il va appeler l&rsquo;un des processus d&rsquo;init suivant (<code>/sbin/init</code>, <code>/etc/init</code>, <code>/bin/init</code>, <code>/bin/sh</code>)</p>
<blockquote>
<p><em>main.c</em> &lsquo;kernel_init()&rsquo;</p>
</blockquote>
<pre><code class=language-c>if (ramdisk_execute_command) {
    ret = run_init_process(ramdisk_execute_command);
    if (!ret)
        return 0;
    pr_err(&quot;Failed to execute %s (error %d)\n&quot;,
           ramdisk_execute_command, ret);
}

/*
 * We try each of these until one succeeds.
 *
 * The Bourne shell can be used instead of init if we are
 * trying to recover a really broken machine.
 */
if (execute_command) {
    ret = run_init_process(execute_command);
    if (!ret)
        return 0;
    panic(&quot;Requested init %s failed (error %d).&quot;,
          execute_command, ret);
}
if (!try_to_run_init_process(&quot;/sbin/init&quot;) ||
    !try_to_run_init_process(&quot;/etc/init&quot;) ||
    !try_to_run_init_process(&quot;/bin/init&quot;) ||
    !try_to_run_init_process(&quot;/bin/sh&quot;))
    return 0;

panic(&quot;No working init found.  Try passing init= option to kernel. &quot;
      &quot;See Linux Documentation/admin-guide/init.rst for guidance.&quot;);
</code></pre>
<h2 id=linit>L&rsquo;init<a class=anchor href=#linit>#</a></h2>
<p>Comme c&rsquo;est le premier processus lancé par le kernel, il porte donc logiquement le numéro <code>PID=1</code>.</p>
<p>Ce processus est un peu différent des autres :</p>
<ul>
<li>Ne peut être tué.</li>
<li>N&rsquo;a pas de parent <code>PPID=</code>.</li>
<li>Est l&rsquo;ancêtre de tous les autres processus.</li>
<li>Est chargé d&rsquo;initialiser tout un nombre de ressources (disque, terminaux, réseau, interface graphique…).</li>
</ul>
<blockquote>
<p>Sous linux les processus sont tous issus de la methode <code>fork()</code> ou dérivés.</p>
<p>Tous les processus enfants héritent d&rsquo;un certain nombre d&rsquo;attributs de leur parent : user, session, cgroup, mémoire partagé&mldr;</p>
<p>L&rsquo;init a donc un rôle primordial dans la vie du système.</p>
</blockquote>
<h2 id=sysv-init>SysV init<a class=anchor href=#sysv-init>#</a></h2>
<p>Pour bien comprendre ce que systemd apporte il faut le comparer à son prédécesseur SysV init (j&rsquo;ai choisi initV uniquement parce que c&rsquo;était le plus répandu et que je l&rsquo;ai un peu utilisé).</p>
<p>SysV init est basé sur les run-levels qui sont au nombre de 5 (presque) :</p>
<ul>
<li>0 - réservé - Arrêt (halt)</li>
<li>1 - Mode utilisateur unique avec les filesystems montés.</li>
<li>2..5 Mode multi-utilisateur, les significations varies suivant les distributions, mais correspond à l&rsquo;état opérationnel de la machine.</li>
<li>6 - réservé - Redémarrage</li>
</ul>
<p>Il faut d&rsquo;ailleurs comprendre le nom SysV init comme étant &ldquo;systeme 5 init&rdquo; qui correspond aux 5 run-level de l&rsquo;état d&rsquo;un système.</p>
<p>Lors de l&rsquo;init le system va passer d&rsquo;un run-level à l&rsquo;autre jusqu&rsquo;à arriver au <em><strong>default level</strong></em> (qui peut varier suivant les distributions&mldr;) qui correspond au mode nominal de fonctionnement (par exemple une interface graphique pour un desktop ou un terminal pour un serveur).</p>
<p>En cas d&rsquo;erreur du level X le level X+1 n&rsquo;est pas appelé et l&rsquo;initialisation est marquée en échec.</p>
<p>Chacun des levels agit comme un point de synchronisation, c&rsquo;est-a-dire qu&rsquo;il va déclencher un nombre d&rsquo;actions à une étape précise du démarrage du système.</p>
<blockquote>
<p>Par exemple si un daemon &ldquo;A&rdquo; nécessite une interface réseau ou filesystem locaux, il a tout intérêt à se déclencher à un run-level supérieur à 1.</p>
</blockquote>
<h2 id=scripts-sysv-init>Scripts SysV init<a class=anchor href=#scripts-sysv-init>#</a></h2>
<p>SysV init est basé sur un ensemble de scripts, qui doivent répondre à des conventions, certaines peuvent varier suivant les distributions Linux utilisées.</p>
<p>Prenons l&rsquo;exemple très simple d&rsquo;un script de lancement d&rsquo;un daemon :</p>
<pre><code class=language-bash>#!/bin/sh #(1)
# 
# Demonstrate creating your own init scripts 
# chkconfig: 2345 91 64 (2) 
### BEGIN INIT INFO (3)
# Provides: Welcome 
# Required-Start: $local_fs $all 
# Required-Stop: 
# Default-Start: 2345 
# Default-Stop: 
# Short-Description: Display a welcome message 
# Description: Just display a message. Not much else. 
###END INIT INFO 

# Source function library. 
. /etc/rc.d/init.d/functions #(4)

lock_file=/var/lock/subsys/myservice

start()  { 
   touch &quot;$lock_file&quot; 
   echo &quot;Starting service&quot; 
   sleep 2
 } 

case &quot;$1&quot; in  #(5)
      start) 
       start
        ;; 

      stop)
       rm -f  &quot;$lock_file&quot; 
       echo &quot;Service is shutting down&quot;  
       sleep 2 
        ;; 

     status)
       if [[ -f &quot;$lock_file&quot; ]]; then
         echo &quot;Service looks good&quot;
       else
         echo &quot;Service not started !!&quot;
       fi
        ;; 

         *)
       echo $&quot;Usage: $0 {start|stop|status}&quot; 
       exit 5 
esac 
exit $? #(6)
</code></pre>
<p>Il est composé :</p>
<ul>
<li>(1) D&rsquo;une déclaration de l&rsquo;interpréteur (ici shell)</li>
<li>Ensuite une série de commentaires qui n&rsquo;en sont pas :
<ul>
<li>(2) chkconfig qui permet de définir les levels d&rsquo;exécution et le niveau de priorité</li>
<li>(3) LSB Headers qui contient des informations sur ordonnancement du service qui peut être éventuellement utilisé</li>
</ul>
</li>
<li>(4) L&rsquo;import des fonctions communes /etc/rc.d/init.d/functions</li>
<li>(5) Un switch case en fonction des arguments &lsquo;start&rsquo; / &lsquo;stop&rsquo; / &lsquo;status&rsquo;</li>
<li>(6) Un code de retour</li>
</ul>
<p><em><strong>PROS</strong></em> :</p>
<ul>
<li>Offre un nombre de fonctionnalités assez completes : ckconfig, lsb-headers.</li>
<li>Une grande flexibilité : c&rsquo;est un script shell on fait &lsquo;ce qu&rsquo;on veut&rsquo;.</li>
<li>Un début de standardisation (avec les fonctions, lsb headers, checkconfig).</li>
</ul>
<p><em><strong>CONS</strong></em> :</p>
<ul>
<li>Très verbeux, répétitif et difficilement extensible.</li>
<li>Repose uniquement sur des conventions (start, stop, status&mldr;).</li>
<li>Compliqué à réaliser.</li>
<li>Peut avoir de comportements différents selon le context d&rsquo;appel du script.</li>
</ul>
<p>D&rsquo;un point de vue utilisateur, on remarque bien que ce n&rsquo;est pas standardisé (avec ses avantages et ses inconvénients) et en pratique demande pas mal d&rsquo;expertise en script pour réaliser des choses assez semblables (gérer les sorties standards, changer d&rsquo;utilisateur, lancer un daemon, execution unique&mldr;)</p>
<p>La ou SysV init se résume à sequencer l&rsquo;exécution de scripts (en schématisant), systemd se base sur de la description de configuration.</p>
<h2 id=service-unit-systemd>Service unit systemd<a class=anchor href=#service-unit-systemd>#</a></h2>
<p>Ces configurations sont écrites au format ini et sont appelées &ldquo;unit file&rdquo; ou &ldquo;unit&rdquo; (mais ce n&rsquo;est pas exact, car ça désigne les objects manipulés par systemd et non les fichiers).</p>
<p>Il existe plusieurs types d&rsquo;unit files qui répondent à différents cas d&rsquo;utilisations (service, montage&mldr;), chacune est suffixée par son type.</p>
<p>L&rsquo;équivalent systemd du script ci-dessus est une unit file de type &ldquo;service&rdquo; que l&rsquo;on pourrait adapter de la sorte :</p>
<pre><code class=language-ini>[Unit]
Description=Service

[Service] 
Type=simple
ExecStart=/usr/bin/sleep 2
ExecPreStop=/usr/bin/sleep 2 

[Install]
Wants=multi-users.target
</code></pre>
<p>La première chose que l&rsquo;on remarque est que le fichier systemd n&rsquo;est pas un script, il n&rsquo;a donc pas d&rsquo;utilité en dehors du contexte de systemd.</p>
<p>Deuxième chose, les attributs de configuration sont normées, ils correspondent à une série de propriétés interprétées par le programme.
Ce n&rsquo;est plus nous qui réalisons les actions, c&rsquo;est systemd qui le fait à notre place.</p>
<p>Le script de base est extrêmement simple, et n&rsquo;a pas vraiment de sens (encore moins avec systemd) mais met bien en evidence toutes les choses qui sont inclus de base dans systemd, et la difference entre les deux approches.</p>
<p>L&rsquo;avantage ici d&rsquo;être dans un &ldquo;framework&rdquo; est qu&rsquo;il prend nativement en charge toutes les tâches usuelles sans avoir à les redéfinir nous même.</p>
<ul>
<li>Un service est un unique, pour un meme nom (au sein d&rsquo;une instance systemd). Nous n&rsquo;avons donc pas besoin de lock de synchronisation (il est possible de le variabiliser via le templating).</li>
<li>Les états start / status / stop / restart sont implicites et commun à tous les services. Il faut noter que le status a souvent une signification un peu différente des scripts initV qui réalisent souvent des tâches de vérification assez complexes. Sous systemd le status ne reporte généralement uniquement l&rsquo;état du <code>PID</code> déterminé comme principal.</li>
<li>Là où l&rsquo;on devait spécifier via les lsb-headers l&rsquo;ordonnancement (after $local_fs) fait ici partie de la valeur par défaut (cf <code>defaultdependencies</code>) qui doit répondre à la majorité des cas d&rsquo;utilisations des daemons de haut niveau.</li>
<li>Enfin on retrouve un équivalent des run-level avec l&rsquo;attribut <code>Target=multi-users.target</code> qui sert ici également de point de synchronisation lors du démarrage.</li>
</ul>
<h2 id=le-mal-aimé>Le mal aimé<a class=anchor href=#le-mal-aimé>#</a></h2>
<p>On a beaucoup reproché a systemd d&rsquo;être envahissant, et de briser le principe &ldquo;un programme doit faire UNE chose et la faire bien&rdquo;.</p>
<p>Oui systemd est envahissant, mais principalement par ce que c&rsquo;est un init system, une des pièces principales des systèmes UNIX. Il est de ce fait chargé de réaliser une multitude d&rsquo;actions très différentes (monter les fs, mettre en place les interfaces réseaux&mldr;).
Ce qui était &ldquo;caché&rdquo; sous des scripts est ici rendu apparent.</p>
<p>Les défenseurs rétorquent souvent que systemd est modulaire - ce qui est vrai - mais cela ne me semble pas être un argument valable, les composants peuvent faire partis de different projets/module (journald, networkd, nspawn&mldr;) ils font tous partis d&rsquo;un ensemble coherent et ont tous vocation à fonctionner ensemble.</p>
<p>À mon avis la principale résistance est que systemd a imposé ses standards (en termes de nomenclature, arborescence, packaging et autres) aux seins des distributions.</p>
<p>J&rsquo;y vois également la réaction à la professionnalisation inévitable de l&rsquo;écosystème Linux, avec la disparition progressive de l&rsquo;esprit pionnier qui perdure dans les communautés de passionnés organisées autour des distributions / projets OSS.
(Il faut aussi bien avouer que la communauté Linux ADORE les dramas et trouver des occasions de s&rsquo;écharper).</p>
<p>Systemd n&rsquo;est certainement pas idéal, mais il est &ldquo;constant&rdquo;.
Il a indéniablement apporté beaucoup de bénéfices : facilitation du packaging, une meilleure portabilité, une qualité accrue et plus homogène, une facilité d&rsquo;accès aux fonctions avancés du kernel&mldr;</p>
<p>Bref, il ne s&rsquo;agit pas de défendre systemd mais bien de mettre en avant les bénéfices qu&rsquo;il apporte.</p>
</article>
<ul class=tags__list>
<li class=tag__item>
<a class=tag__link href=https://cyrillesondag.github.io/tags/linux/>linux</a>
</li>
<li class=tag__item>
<a class=tag__link href=https://cyrillesondag.github.io/tags/systemd/>systemd</a>
</li></ul>
<div class=pagination>
<a class=pagination__item href=https://cyrillesondag.github.io/blog/presentation-linux-menory/>
<span class=pagination__label>Previous Post</span>
<span class=pagination__title>Présentation Linux Memory</span>
</a>
</div>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//github-blog-tpysk8cw2i.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
<footer class=post__footer>
<div class=social-icons>
<a class=social-icons__link title=Twitter href=https://twitter.com/CyrilleSondag target=_blank rel="me noopener">
<div class=social-icons__icon style=background-image:url(https://cyrillesondag.github.io/svg/twitter.svg)></div>
</a>
<a class=social-icons__link title=GitHub href=https://github.com/cyrillesondag target=_blank rel="me noopener">
<div class=social-icons__icon style=background-image:url(https://cyrillesondag.github.io/svg/github.svg)></div>
</a>
<a class=social-icons__link title=Email href=mailto:cyrille.sondag@gmail.com target=_blank rel="me noopener">
<div class=social-icons__icon style=background-image:url(https://cyrillesondag.github.io/svg/email.svg)></div>
</a>
</div>
<p>© 2021</p>
</footer>
</div>
</div>
<div class=toc-container>
<nav id=TableOfContents>
<ul>
<li><a href=#historique>Historique</a></li>
<li><a href=#du-boot-à-linit>Du boot à l&rsquo;init</a>
<ul>
<li></li>
</ul>
</li>
<li><a href=#linit>L&rsquo;init</a></li>
<li><a href=#sysv-init>SysV init</a></li>
<li><a href=#scripts-sysv-init>Scripts SysV init</a></li>
<li><a href=#service-unit-systemd>Service unit systemd</a></li>
<li><a href=#le-mal-aimé>Le mal aimé</a></li>
</ul>
</nav>
</div>
</div>
</main>
<script src=/js/index.min.575dda8d49ee02639942c63564273e6da972ab531dda26a08800bdcb477cbd7f.js integrity="sha256-V13ajUnuAmOZQsY1ZCc+balyq1Md2iagiAC9y0d8vX8=" crossorigin=anonymous></script>
<script src=https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js data-autoloader-path=https://unpkg.com/prismjs@1.20.0/components/></script>
<script src=/js/table-of-contents.js></script>
</body>
</html>