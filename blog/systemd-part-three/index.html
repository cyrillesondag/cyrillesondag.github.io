<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Systemd - partie 3 | Yet another tech blog</title><meta name=keywords content="linux,systemd,init system"><meta name=description content="Systemd architecture"><meta name=author content="Cyrille Sondag"><link rel=canonical href=https://cyrillesondag.github.io/blog/systemd-part-three/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://cyrillesondag.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cyrillesondag.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cyrillesondag.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cyrillesondag.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cyrillesondag.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cyrillesondag.github.io/blog/systemd-part-three/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://cyrillesondag.github.io/blog/systemd-part-three/"><meta property="og:site_name" content="Yet another tech blog"><meta property="og:title" content="Systemd - partie 3"><meta property="og:description" content="Systemd architecture"><meta property="og:locale" content="fr-fr"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-02-11T10:34:56+02:00"><meta property="article:modified_time" content="2025-12-02T17:43:25+01:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Systemd"><meta name=twitter:card content="summary"><meta name=twitter:title content="Systemd - partie 3"><meta name=twitter:description content="Systemd architecture"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://cyrillesondag.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Systemd - partie 3","item":"https://cyrillesondag.github.io/blog/systemd-part-three/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Systemd - partie 3","name":"Systemd - partie 3","description":"Systemd architecture","keywords":["linux","systemd","init system"],"articleBody":" Jean Auguste Dominique Ingres - Portrait d’une jeune femme (1766–1817), huile sur toile, 59.6 x 73.2 cm, Hull (UK), Ferens Art Gallery.\nCet article sera consacré à l’architecture de systemd.\nLe cœur de systemd est basé sur quelques piliers : UDev et DBus qui permettent de mettre en place une approche évènementielle, les CGroup pour l’encapsulation des processus et le contrôle des ressources et plus récemment EBPF pour les métriques.\nArchitecture de systemd - By Shmuel Csaba Otto Traian, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=28698339\nIl se base sur plusieurs principes forts que je vais tenter de détailler ci-dessous.\nRetarder l’initialisation L’un des objectifs initiaux du projet était d’améliorer le temps de démarrage des systèmes jugé à juste titre trop long.\nIl faut garder à l’esprit qu’il a été pensé pour répondre à ces différents cas d’utilisation (serveur, station de travail, embarqué…). Si le temps de démarrage n’est (souvent) pas crucial pour un serveur, ce n’est absolument pas le cas pour une station de travail ou pour un mobile.\nPour arriver à cela plusieurs types d’unit sont chargés uniquement de l’activation des services lors de leur première utilisation. On peut citer les types : socket, path, automount …\nCela permet d’éviter de lancer un service trop tôt (bien souvent au démarrage) et ainsi optimiser le temps de d’initialisation.\nPour réaliser cela systemd utilise plusieurs méthodes d’activation :\nLes Socket. Le principe est assez simple et est largement inspiré de ce qui se faisait déjà sur inetd. Mais contrairement à ce dernier, de nombreux types de socket sont maintenant supportés : UNIX, INET, named pipes, netlink…\nOn peut résumer les étapes de la façon suivante :\nDes buffers sont alloués automatiquement au démarrage pour chaque service qui le demande. Lors d’un appel, ces buffers se remplissent jusqu’à une taille limite au-delà de laquelle l’écriture devient impossible. Dans ce cas le client se met alors en attente et l’appel devient bloquant (c’est ce qui se passe d’ailleurs lorsqu’il attend une réponse). Les descripteurs de fichiers sont scrutés et au premier message le service consommateur est démarré en parallèle. Enfin on lui transmet le(s) socket(s) en paramètres afin qu’il puisse les lire une fois initialisé. En cas d’échec de démarrage, rien n’est lu et le service peut être relancé sans pertes d’informations. Néanmoins, attention le passage de sockets n’est pas un comportement “natif” sous Linux. Il faut donc que le service soit compatible avec systemd (c’est heureusement le cas de nombreux serveurs web entre autres).\nGrâce à ce comportement, on peut non seulement activer un service au premier appel, mais également briser les chaines de dépendances entre services et paralléliser leur activation.\nPar exemple dans le cas d’un service qui nécessite syslog : Il est possible de lancer les deux en parallèle, les messages syslog seront envoyés mis en attente dans le buffer avant d’être dépilé à l’initialisation complète de syslog.\nUDev UDev est un daemon qui permet d’exposer dans l’espace utilisateur les périphériques de façon dynamique. Il prend en charge le hot-plug mais aussi pour les périphériques classiques.\nC’est un daemon qui écoute dans l’espace utilisateur les évènements publiés par le kernel via netlink (un socket entre le kernel et l’espace utilisateur).\nIl fait ensuite la liaison entres les informations du sysfs et déclenche des règles spécifiques écrites par un administrateur.\nCe projet a acquis une telle importance qu’il fait maintenant partie à part entière de systemd.\nPrenons un exemple concret de comment utiliser UDev avec systemd.\nTout d’abord nous pouvons écouter les évènements publiés par le kernel et UDev ainsi :\n1 udevadm monitor Ce qui donne ce résultat lors de l’activation de bluetooth sur mon portable\n1 2 3 4 5 6 7 8 9 10 11 12 monitor will print the received events for: UDEV - the event which udev sends out after rule processing KERNEL - the kernel uevent KERNEL[88503.920800] change /devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0/bluetooth/hci0/rfkill0 (rfkill) UDEV [88503.926695] change /devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0/bluetooth/hci0/rfkill0 (rfkill) KERNEL[88521.147695] add /devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0/bluetooth/hci0/hci0:256 (bluetooth) UDEV [88521.151331] add /devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0/bluetooth/hci0/hci0:256 (bluetooth) KERNEL[88522.280203] add /devices/virtual/input/input24 (input) KERNEL[88522.280341] add /devices/virtual/input/input24/event18 (input) UDEV [88522.282180] add /devices/virtual/input/input24 (input) UDEV [88522.319399] add /devices/virtual/input/input24/event18 (input) La première partie concerne la mise en route du récepteur bluetooth, la seconde la connexion du casque audio.\nOn voit apparaître un nouveau device sous l’arborescence /devices/virtual/input/input24.\nEnsuite on cherche à écrire une règle UDev qui va s’activer uniquement pour ce périphérique. Pour cela il nous faut donc chercher les attributs discriminants dans les événements UDev que l’on peut voir à l’aide de la commande (attention les chemins UDev sont toujours relatifs aux répertoires /sys ou /dev/):\n1 udevadm info -a /sys/devices/virtual/input/input24 Je serais bien incapable d’expliquer la signification de tous les attributs, par contre je peux en reconnaître quelque uns comme le nom et son adresse (qui me semble assez unique) :\n1 2 3 4 5 6 7 8 9 10 KERNEL==\"input24\" SUBSYSTEM==\"input\" DRIVER==\"\" .... ATTR{inhibited}==\"0\" ATTR{name}==\"LG-TONE-FP9 (AVRCP)\" ATTR{phys}==\"0c:dd:24:30:06:00\" ATTR{power/async}==\"disabled\" ATTR{power/control}==\"auto\" .... Ensuite avec ces informations on est en mesure d’écrire une règle appropriée pour sélectionner ce matériel de la façon suivante :\n1 SUBSYSTEM==\"input\", ATTR{name}==\"LG-TONE-FP9 (AVRCP)\", ATTR{phys}==\"0c:dd:24:30:06:00\", TAG+=\"systemd\", ENV{SYSTEMD_ALIAS}+=\"/sys/devices/virtual/input/lg_tone_fp9\" Les premiers éléments servent à sélectionner les attributs dans les événements UDev qui vont déclencher la règle : le nom du system, l’attribut nom et son adresse.\nPuis la partie importante pour l’intégration avec systemd est TAG+=\"systemd. Ce tag permet de marquer le périphérique pour être interprété comme une unit “.device”.\nC’est d’ailleurs la seule chose à faire pour faire fonctionner cette règle avec systemd.\nJ’ai ajouté l’attribut SYSTEMD_ALIAS= car le chemin du périphérique n’est pas prévisible (/sys/devices/virtual/input/input).\nComme le nom de la unit est déterminé par son chemin il est plus simple qu’il soit toujours le même. Maintenant ce device va apparaître systématiquement sous le nom sys-devices-virtual-input-lg_tone_fp9.device.\nOn est donc en mesure d’écrire un service qui va s’activer lors de la présence de ce device.\n1 2 3 4 5 6 [Unit] Wants=sys-devices-virtual-input-lg_tone_fp9.device [Service] ExecStart=/bin/echo headphone connected RemainAfterExit=true Il existe également la possibilité d’activer un service directement à partir d’une règle UDev.\nD-Bus D-Bus est un nouvel framework d’IPC (inter-process communication) qui permet de communiquer de façon standardisée entre différents services. Il permet - entre autre - de faire :\ndu RPC (Remote Procedure Call) en offrant une sérialisation standardisée. de sécuriser les communications via un mécanisme d’autorisation. de l’activation à la demande via un système de nommage. de la découverte de service … Systemd est complètement intégré avec D-Bus (l’architecture des deux produits est par ailleurs assez similaire).\nIl est ainsi possible d’interagir avec systemd uniquement via les API D-BUS.\nPour voir les services exposés par DBus il suffit de taper la commande :\n1 2 3 4 ~ busctl list --acquired NAME PID PROCESS USER CONNECTION UNIT SESSION DESCRIPTION ... org.freedesktop.systemd1 1 systemd root :1.1 init.scope - - On peut également voir l’ensemble des propriétés d’un service\n1 ~ busctl introspect org.freedesktop.systemd1 /org/freedesktop/systemd1 Puis pour lister les propriétés, méthodes d’un service (systemd ici) :\n1 ~ busctl introspect org.freedesktop.systemd1 /org/freedesktop/systemd1 Cela donne accès à l’ensemble des objets accessibles via D-BUS (c’est aussi un bon moyen pour connaître les valeurs des propriétés par défaut).\nOn peut également écrire un service activable lors de la présence d’un bus de la façon suivante :\n1 2 3 4 5 6 7 Unit] Description=Simple DBus service [Service] Type=dbus BusName=org.example.simple-dbus-service ExecStart=/usr/sbin/simple-dbus-service Bref les possibilités sont impressionnantes, tellement l’intégration des deux systèmes est poussée.\nInotify Inotify est un mécanisme qui permet d’observer les actions sur un système de fichiers.\nIl permet de s’abonner à un répertoire ou fichier et de recevoir les types d’évènements suivants :\nIN_ACCESS : le fichier est accédé en lecture ; IN_MODIFY : le fichier est modifié ; IN_ATTRIB : les attributs du fichier sont modifiés ; IN_OPEN : le fichier est ouvert ; IN_DELETE : un fichier a été supprimé dans le répertoire surveillé ; IN_CREATE : un fichier a été créé dans le répertoire surveillé. … En symétrie nous allons donc retrouver sous systemd les fonctions suivantes PathExists=, PathChanged=, PathModified=, DirectoryNotEmpty=\nAttention - comme spécifié dans la documentation - inotify souffre de certaines limitations, il n’est par exemple pas possible de scruter les évènements produits par une machine distante sur une filesystem en réseau (type NFS).\nAutofs Autofs est un module du kernel qui permet de retarder le montage d’un FS. Pour cela il crée des mount-trap (des dentry avec un attribut particulier) qui au premier accès (au-delà du stat) va faire appel à un daemon - dans notre cas systemd - qui va effectuer le montage. Par la suite le filesystem pourra être utilisé comme un FS habituel.\nCela offre deux avantages :\nalors que l’initialisation classique attend le montage de tous les FS (qui dans le cas de FS en réseaux peut être assez long), ici nous n’avons plus à attendre cette étape. cela permet également de paralléliser les montages. Paralléliser On l’a vu plus haut - en plus du chargement à la demande - beaucoup de composants facilitent la parallélisation des actions et font ainsi gagner en efficacité.\nDe son côté systemd se base sur son modèle de dépendances et cherche à minimiser les points de synchronisations qui ralentissent le démarrage.\nPour cela il va construire un arbre de dépendances pour pouvoir lancer un maximum de services en parallèle en ayant à attendre uniquement ceux qui lui sont nécessaires.\nPour arriver à cela des ordonnancements - souvent implicites - sont mis en place suivant différents critères afin de garantir la bonne cohérence des actions (c’est d’ailleurs souvent la partie la plus complexe à mettre en œuvre à mon avis).\nPour illustrer mes propos voici le graphique de démarrage, pour atteindre la default.target :\nBootup graph\nÀ noter quelques points qui me semblent importants :\nLorsque systemd active un nombre de unit - et si aucun ordre n’est spécifié - elles sont faites en parallèle. Par défaut les services s’exécutent après la sysinit.target (ou à la basic.target en mode user). Pour passer outre il faut ajouter la propriété DefaultDependencies=false. Comme souvent des outils sont mis à disposition pour nous aider : On peut citer systemd-analyse plot (en SVG) ou systemd-analyse dot (au format DOT) qui permettent de générer des représentations graphiques de ce que nous venons d’aborder.\nL’utilisation des cgroups Contrairement à ce que l’on pourrait croire le cgroups ne sont pas utilisés (du moins au départ) dans systemd pour le contrôle de resources, mais pour le contrôle des processus.\nIl s’avère en pratique compliqué de terminer correctement un service ayant un nombre de processus forkés important.\nPour tenter de comprendre le problème, revenons sur quelques notions UNIX :\nUn processus est rattaché à une session. Par convention le SID il est égal au PID du premier membre de la session, le “session leader”. La session peut être un terminal, une connexion ssh… ou autre.\nDans une session on trouve un certain nombre de groupes de processus. Le PGID est égal au PID du premier membre du groupe le “process group leader” (vous voyez la logique). Au sein d’une session un seul groupe peut être au premier plan.\nUn processus PID a (presque) toujours un parent et hérite de certains de ses attributs (UID, GID, SID, PGID…). Il est lui-même composé de plusieurs threads.\nSi en théorie c’est simple, en pratique, c’est assez compliqué : liberté d’implémentation, différences entre les systèmes UNIX, manque de syscall… Tout cela a fait qu’il est difficile de suivre correctement l’ensemble des processus issus de différents forks.\nPar exemple l’une des techniques couramment utilisées pour lancer un processus en arrière-plan (daemon) est la technique dite du “double-fork”. Elle consiste à effectuer les opérations suivantes :\nUn premier fork() pour créer un processus enfant de façon classique. Qui va ensuite appeler setsid(0) pour se détacher de la session courante. Pour enfin effectuer un nouveau fork() pour que ce changement soit pris en compte. Le processus nouvellement créé est ainsi rendu orphelin et ne peut plus interagir avec la session d’origine (et vice versa). Du point de vue d’un init manager, le problème est qu’il n’a connaissance que du PID issu du retour du premier fork, et pas de celui issu du second et éventuellement des autres processus forkés.\nUne parade consistait à stocker le résultat du second fork dans un fichier PID file pour pouvoir le retrouver. Cette méthode est tout à fait valide, mais souffre de limites en cas de nouveau fork et est de plus très dépendante de l’implémentation qui en est faite.\nOn peut me faire remarquer que systemd utilise aussi des pid file, oui mais :\nc’est surtout pour assurer la rétrocompatibilité avec les anciens scripts. ce n’est pas exactement utilisé pour la même fonction (principalement par le watchdog). Pour pallier ce problème, systemd utilise les CGroup.\nPrésent depuis longtemps dans le kernel Linux les CGroups sont prévus pour régler ce type de problème. À la différence d’autres propriétés un processus ne peut pas s’échapper d’un CGroup (à moins de créer un nouveau sous CGroup qui reste néanmoins toujours le descendant du parent). Il est de plus assez aisé de recenser l’ensemble des processus d’un CGroup.\nSystemd a donc décidé de lancer tous les services dans leurs propres CGroup, cela permet de résoudre une bonne fois pour toutes les problèmes d’échappement des processus.\nEt encore une fois fournit un outil pour nous aider :\n1 systemd-cgls ","wordCount":"2206","inLanguage":"en","datePublished":"2022-02-11T10:34:56+02:00","dateModified":"2025-12-02T17:43:25+01:00","author":{"@type":"Person","name":"Cyrille Sondag"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cyrillesondag.github.io/blog/systemd-part-three/"},"publisher":{"@type":"Organization","name":"Yet another tech blog","logo":{"@type":"ImageObject","url":"https://cyrillesondag.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://cyrillesondag.github.io/ accesskey=h title="Yet another tech blog (Alt + H)">Yet another tech blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cyrillesondag.github.io/ title=Accueil><span>Accueil</span></a></li><li><a href=https://cyrillesondag.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://cyrillesondag.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cyrillesondag.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cyrillesondag.github.io/blog/>Blogs</a></div><h1 class="post-title entry-hint-parent">Systemd - partie 3</h1><div class=post-description>Systemd architecture</div><div class=post-meta><span title='2022-02-11 10:34:56 +0200 +0200'>11 February 2022</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>Cyrille Sondag</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#retarder-linitialisation aria-label="Retarder l&rsquo;initialisation">Retarder l&rsquo;initialisation</a><ul><li><a href=#les-socket aria-label="Les Socket.">Les Socket.</a><ul><li><a href=#udev aria-label=UDev>UDev</a></li></ul></li><li><a href=#d-bus aria-label=D-Bus>D-Bus</a></li><li><a href=#inotify aria-label=Inotify>Inotify</a></li><li><a href=#autofs aria-label=Autofs>Autofs</a></li></ul></li><li><a href=#parall%c3%a9liser aria-label=Paralléliser>Paralléliser</a></li><li><a href=#lutilisation-des-cgroups aria-label="L&rsquo;utilisation des cgroups">L&rsquo;utilisation des cgroups</a></li></ul></div></details></div><div class=post-content><figure><a href=Jean_Auguste_Dominique_Ingres_-_Portrait_of_a_Young_Woman_%28formerly_thought_to_be_Mme_de_Sta%c3%abl,_1766%e2%80%931817%29.jpg><img sizes="(min-width: 35em) 1200px, 100vw" srcset='https://cyrillesondag.github.io/blog/systemd-part-three/Jean_Auguste_Dominique_Ingres_-_Portrait_of_a_Young_Woman_%28formerly_thought_to_be_Mme_de_Sta%C3%ABl,_1766%E2%80%931817%29_hu_b6df43bd59b9fdae.jpg 480w,
https://cyrillesondag.github.io/blog/systemd-part-three/Jean_Auguste_Dominique_Ingres_-_Portrait_of_a_Young_Woman_%28formerly_thought_to_be_Mme_de_Sta%C3%ABl,_1766%E2%80%931817%29_hu_16d971948921ad07.jpg 800w,
https://cyrillesondag.github.io/blog/systemd-part-three/Jean_Auguste_Dominique_Ingres_-_Portrait_of_a_Young_Woman_%28formerly_thought_to_be_Mme_de_Sta%C3%ABl,_1766%E2%80%931817%29_hu_4e1ef40c3db9f7a0.jpg 1200w,' src=https://cyrillesondag.github.io/blog/systemd-part-three/Jean_Auguste_Dominique_Ingres_-_Portrait_of_a_Young_Woman_%28formerly_thought_to_be_Mme_de_Sta%C3%ABl,_1766%E2%80%931817%29_hu_16d971948921ad07.jpg alt="Jean Auguste Dominique Ingres - Portrait d&rsquo;une jeune femme (1766–1817), huile sur toile, 59.6 x 73.2 cm, Hull (UK), Ferens Art Gallery."></a><figcaption style=font-size:80%;text-align:center><p>Jean Auguste Dominique Ingres - Portrait d&rsquo;une jeune femme (1766–1817), huile sur toile, 59.6 x 73.2 cm, Hull (UK), Ferens Art Gallery.</p></figcaption></figure><p>Cet article sera consacré à l&rsquo;architecture de <em>systemd</em>.</p><p>Le cœur de systemd est basé sur quelques piliers : <em>UDev</em> et <em>DBus</em> qui permettent de mettre en place une approche évènementielle, les <em>CGroup</em> pour l&rsquo;encapsulation des processus et le contrôle des ressources et plus récemment <em>EBPF</em> pour les métriques.<br><br><figure><a href=Systemd_components.svg.png><img sizes="(min-width: 35em) 1200px, 100vw" srcset='https://cyrillesondag.github.io/blog/systemd-part-three/Systemd_components.svg_hu_bf7855a7b1ad0e55.png 480w,' src=https://cyrillesondag.github.io/blog/systemd-part-three/Systemd_components.svg.png alt="Architecture de systemd - By Shmuel Csaba Otto Traian, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=28698339"></a><figcaption style=font-size:80%;text-align:center><p>Architecture de systemd - By Shmuel Csaba Otto Traian, CC BY-SA 3.0, <a href="https://commons.wikimedia.org/w/index.php?curid=28698339">https://commons.wikimedia.org/w/index.php?curid=28698339</a></p></figcaption></figure></p><p>Il se base sur plusieurs principes forts que je vais tenter de détailler ci-dessous.</p><h2 id=retarder-linitialisation>Retarder l&rsquo;initialisation<a hidden class=anchor aria-hidden=true href=#retarder-linitialisation>#</a></h2><p>L&rsquo;un des objectifs initiaux du projet était d&rsquo;améliorer le temps de démarrage des systèmes jugé à juste titre trop long.</p><p>Il faut garder à l&rsquo;esprit qu&rsquo;il a été pensé pour répondre à ces différents cas d&rsquo;utilisation (serveur, station de travail, embarqué&mldr;).
Si le temps de démarrage n&rsquo;est (souvent) pas crucial pour un serveur, ce n&rsquo;est absolument pas le cas pour une station de travail ou pour un mobile.</p><p>Pour arriver à cela plusieurs types d&rsquo;<em>unit</em> sont chargés uniquement de l&rsquo;activation des services lors de leur première utilisation.
On peut citer les types : socket, path, automount &mldr;</p><p>Cela permet d&rsquo;éviter de lancer un service trop tôt (bien souvent au démarrage) et ainsi optimiser le temps de d&rsquo;initialisation.</p><p>Pour réaliser cela systemd utilise plusieurs méthodes d&rsquo;activation :</p><h3 id=les-socket>Les Socket.<a hidden class=anchor aria-hidden=true href=#les-socket>#</a></h3><p>Le principe est assez simple et est largement inspiré de ce qui se faisait déjà sur <em>inetd</em>.
Mais contrairement à ce dernier, de nombreux types de socket sont maintenant supportés : UNIX, INET, named pipes, netlink&mldr;</p><p>On peut résumer les étapes de la façon suivante :</p><ul><li>Des buffers sont alloués automatiquement au démarrage pour chaque service qui le demande.</li><li>Lors d&rsquo;un appel, ces buffers se remplissent jusqu&rsquo;à une taille limite au-delà de laquelle l&rsquo;écriture devient impossible. Dans ce cas le client se met alors en attente et l&rsquo;appel devient bloquant (c&rsquo;est ce qui se passe d&rsquo;ailleurs lorsqu&rsquo;il attend une réponse).</li><li>Les descripteurs de fichiers sont scrutés et au premier message le service consommateur est démarré en parallèle.</li><li>Enfin on lui transmet le(s) socket(s) en paramètres afin qu&rsquo;il puisse les lire une fois initialisé. En cas d&rsquo;échec de démarrage, rien n&rsquo;est lu et le service peut être relancé sans pertes d&rsquo;informations.</li></ul><p>Néanmoins, attention le passage de sockets n&rsquo;est pas un comportement &ldquo;natif&rdquo; sous Linux.
Il faut donc que le service soit compatible avec systemd (c&rsquo;est heureusement le cas de nombreux serveurs web entre autres).</p><p>Grâce à ce comportement, on peut non seulement activer un service au premier appel, mais également briser les chaines de dépendances entre services et paralléliser leur activation.</p><p>Par exemple dans le cas d&rsquo;un service qui nécessite syslog :
Il est possible de lancer les deux en parallèle, les messages syslog seront envoyés mis en attente dans le buffer avant d&rsquo;être dépilé à l&rsquo;initialisation complète de syslog.</p><h4 id=udev>UDev<a hidden class=anchor aria-hidden=true href=#udev>#</a></h4><p><em>UDev</em> est un daemon qui permet d&rsquo;exposer dans l&rsquo;espace utilisateur les périphériques de façon dynamique.
Il prend en charge le hot-plug mais aussi pour les périphériques classiques.</p><p>C&rsquo;est un daemon qui écoute dans l&rsquo;espace utilisateur les évènements publiés par le kernel via <em>netlink</em> (un socket entre le kernel et l&rsquo;espace utilisateur).</p><p>Il fait ensuite la liaison entres les informations du sysfs et déclenche des règles spécifiques écrites par un administrateur.</p><p>Ce projet a acquis une telle importance qu&rsquo;il fait maintenant partie à part entière de systemd.</p><p>Prenons un exemple concret de comment utiliser <em>UDev</em> avec systemd.</p><p>Tout d&rsquo;abord nous pouvons écouter les évènements publiés par le kernel et <em>UDev</em> ainsi :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>udevadm monitor
</span></span></code></pre></td></tr></table></div></div><p>Ce qui donne ce résultat lors de l&rsquo;activation de bluetooth sur mon portable</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>monitor will print the received events for:
</span></span><span class=line><span class=cl>UDEV - the event which udev sends out after rule processing
</span></span><span class=line><span class=cl>KERNEL - the kernel uevent
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>KERNEL[88503.920800] change   /devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0/bluetooth/hci0/rfkill0 (rfkill)
</span></span><span class=line><span class=cl>UDEV  [88503.926695] change   /devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0/bluetooth/hci0/rfkill0 (rfkill)
</span></span><span class=line><span class=cl>KERNEL[88521.147695] add      /devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0/bluetooth/hci0/hci0:256 (bluetooth)
</span></span><span class=line><span class=cl>UDEV  [88521.151331] add      /devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0/bluetooth/hci0/hci0:256 (bluetooth)
</span></span><span class=line><span class=cl>KERNEL[88522.280203] add      /devices/virtual/input/input24 (input)
</span></span><span class=line><span class=cl>KERNEL[88522.280341] add      /devices/virtual/input/input24/event18 (input)
</span></span><span class=line><span class=cl>UDEV  [88522.282180] add      /devices/virtual/input/input24 (input)
</span></span><span class=line><span class=cl>UDEV  [88522.319399] add      /devices/virtual/input/input24/event18 (input)
</span></span></code></pre></td></tr></table></div></div><p>La première partie concerne la mise en route du récepteur bluetooth, la seconde la connexion du casque audio.</p><p>On voit apparaître un nouveau device sous l&rsquo;arborescence <code>/devices/virtual/input/input24</code>.</p><p>Ensuite on cherche à écrire une règle UDev qui va s&rsquo;activer uniquement pour ce périphérique.
Pour cela il nous faut donc chercher les attributs discriminants dans les événements <em>UDev</em> que l&rsquo;on peut voir à l&rsquo;aide de la commande (attention les chemins UDev sont toujours relatifs aux répertoires <code>/sys</code> ou <code>/dev/</code>):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>udevadm info -a /sys/devices/virtual/input/input24
</span></span></code></pre></td></tr></table></div></div><p>Je serais bien incapable d&rsquo;expliquer la signification de tous les attributs, par contre je peux en reconnaître quelque uns comme le nom et son adresse (qui me semble assez unique) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  KERNEL==&#34;input24&#34;
</span></span><span class=line><span class=cl>  SUBSYSTEM==&#34;input&#34;
</span></span><span class=line><span class=cl>  DRIVER==&#34;&#34;
</span></span><span class=line><span class=cl>  ....
</span></span><span class=line><span class=cl>  ATTR{inhibited}==&#34;0&#34;
</span></span><span class=line><span class=cl>  ATTR{name}==&#34;LG-TONE-FP9 (AVRCP)&#34;
</span></span><span class=line><span class=cl>  ATTR{phys}==&#34;0c:dd:24:30:06:00&#34;
</span></span><span class=line><span class=cl>  ATTR{power/async}==&#34;disabled&#34;
</span></span><span class=line><span class=cl>  ATTR{power/control}==&#34;auto&#34;
</span></span><span class=line><span class=cl>  ....
</span></span></code></pre></td></tr></table></div></div><p>Ensuite avec ces informations on est en mesure d&rsquo;écrire une règle appropriée pour sélectionner ce matériel de la façon suivante :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SUBSYSTEM==&#34;input&#34;,  ATTR{name}==&#34;LG-TONE-FP9 (AVRCP)&#34;, ATTR{phys}==&#34;0c:dd:24:30:06:00&#34;, TAG+=&#34;systemd&#34;, ENV{SYSTEMD_ALIAS}+=&#34;/sys/devices/virtual/input/lg_tone_fp9&#34; 
</span></span></code></pre></td></tr></table></div></div><p>Les premiers éléments servent à sélectionner les attributs dans les événements <em>UDev</em> qui vont déclencher la règle : le nom du system, l&rsquo;attribut nom et son adresse.</p><p>Puis la partie importante pour l&rsquo;intégration avec systemd est <code>TAG+="systemd</code>.
Ce tag permet de marquer le périphérique pour être interprété comme une unit &ldquo;.device&rdquo;.</p><p>C&rsquo;est d&rsquo;ailleurs la seule chose à faire pour faire fonctionner cette règle avec systemd.</p><p>J&rsquo;ai ajouté l&rsquo;attribut <code>SYSTEMD_ALIAS=</code> car le chemin du périphérique n&rsquo;est pas prévisible (<code>/sys/devices/virtual/input/input&lt;X></code>).</p><p>Comme le nom de la unit est déterminé par son chemin il est plus simple qu&rsquo;il soit toujours le même.
Maintenant ce device va apparaître systématiquement sous le nom <code>sys-devices-virtual-input-lg_tone_fp9.device</code>.</p><p>On est donc en mesure d&rsquo;écrire un service qui va s&rsquo;activer lors de la présence de ce device.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[Unit]</span>
</span></span><span class=line><span class=cl><span class=na>Wants</span><span class=o>=</span><span class=s>sys-devices-virtual-input-lg_tone_fp9.device</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Service]</span>
</span></span><span class=line><span class=cl><span class=na>ExecStart</span><span class=o>=</span><span class=s>/bin/echo headphone connected</span>
</span></span><span class=line><span class=cl><span class=na>RemainAfterExit</span><span class=o>=</span><span class=s>true</span>
</span></span></code></pre></td></tr></table></div></div><p>Il existe également la possibilité d&rsquo;activer un service directement à partir d&rsquo;une règle <em>UDev</em>.</p><h3 id=d-bus>D-Bus<a hidden class=anchor aria-hidden=true href=#d-bus>#</a></h3><p><em>D-Bus</em> est un nouvel framework d&rsquo;IPC (inter-process communication) qui permet de communiquer de façon standardisée entre différents services.
Il permet - entre autre - de faire :</p><ul><li>du RPC (Remote Procedure Call) en offrant une sérialisation standardisée.</li><li>de sécuriser les communications via un mécanisme d&rsquo;autorisation.</li><li>de l&rsquo;activation à la demande via un système de nommage.</li><li>de la découverte de service</li><li>&mldr;</li></ul><p>Systemd est complètement intégré avec D-Bus (l&rsquo;architecture des deux produits est par ailleurs assez similaire).</p><p>Il est ainsi possible d&rsquo;interagir avec systemd uniquement via les API <em>D-BUS</em>.</p><p>Pour voir les services exposés par DBus il suffit de taper la commande :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>~ busctl list --acquired
</span></span><span class=line><span class=cl>NAME                                 PID PROCESS         USER             CONNECTION UNIT                             SESSION DESCRIPTION
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>org.freedesktop.systemd1               <span class=m>1</span> systemd         root             :1.1       init.scope                       -       -
</span></span></code></pre></td></tr></table></div></div><p>On peut également voir l&rsquo;ensemble des propriétés d&rsquo;un service</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>~ busctl introspect org.freedesktop.systemd1 /org/freedesktop/systemd1
</span></span></code></pre></td></tr></table></div></div><p>Puis pour lister les propriétés, méthodes d&rsquo;un service (systemd ici) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>~ busctl introspect org.freedesktop.systemd1 /org/freedesktop/systemd1
</span></span></code></pre></td></tr></table></div></div><p>Cela donne accès à l&rsquo;ensemble des objets accessibles via <em>D-BUS</em> (c&rsquo;est aussi un bon moyen pour connaître les valeurs des propriétés par défaut).</p><p>On peut également écrire un service activable lors de la présence d&rsquo;un bus de la façon suivante :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=na>Unit]</span>
</span></span><span class=line><span class=cl><span class=na>Description</span><span class=o>=</span><span class=s>Simple DBus service</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Service]</span>
</span></span><span class=line><span class=cl><span class=na>Type</span><span class=o>=</span><span class=s>dbus</span>
</span></span><span class=line><span class=cl><span class=na>BusName</span><span class=o>=</span><span class=s>org.example.simple-dbus-service</span>
</span></span><span class=line><span class=cl><span class=na>ExecStart</span><span class=o>=</span><span class=s>/usr/sbin/simple-dbus-service</span>
</span></span></code></pre></td></tr></table></div></div><p>Bref les possibilités sont impressionnantes, tellement l&rsquo;intégration des deux systèmes est poussée.</p><h3 id=inotify>Inotify<a hidden class=anchor aria-hidden=true href=#inotify>#</a></h3><p><em>Inotify</em> est un mécanisme qui permet d&rsquo;observer les actions sur un système de fichiers.</p><p>Il permet de s&rsquo;abonner à un répertoire ou fichier et de recevoir les types d&rsquo;évènements suivants :</p><ul><li>IN_ACCESS : le fichier est accédé en lecture ;</li><li>IN_MODIFY : le fichier est modifié ;</li><li>IN_ATTRIB : les attributs du fichier sont modifiés ;</li><li>IN_OPEN : le fichier est ouvert ;</li><li>IN_DELETE : un fichier a été supprimé dans le répertoire surveillé ;</li><li>IN_CREATE : un fichier a été créé dans le répertoire surveillé.</li><li>&mldr;</li></ul><p>En symétrie nous allons donc retrouver sous systemd les fonctions suivantes <code>PathExists=, PathChanged=, PathModified=, DirectoryNotEmpty=</code></p><p>Attention - comme spécifié dans la documentation - <em>inotify</em> souffre de certaines limitations, il n&rsquo;est par exemple pas possible de scruter les évènements produits par une machine distante sur une filesystem en réseau (type NFS).</p><h3 id=autofs>Autofs<a hidden class=anchor aria-hidden=true href=#autofs>#</a></h3><p><em>Autofs</em> est un module du kernel qui permet de retarder le montage d&rsquo;un FS.
Pour cela il crée des <em>mount-trap</em> (des dentry avec un attribut particulier) qui au premier accès (au-delà du stat) va faire appel à un daemon - dans notre cas systemd - qui va effectuer le montage.
Par la suite le filesystem pourra être utilisé comme un FS habituel.</p><p>Cela offre deux avantages :</p><ul><li>alors que l&rsquo;initialisation classique attend le montage de tous les FS (qui dans le cas de FS en réseaux peut être assez long), ici nous n&rsquo;avons plus à attendre cette étape.</li><li>cela permet également de paralléliser les montages.</li></ul><h2 id=paralléliser>Paralléliser<a hidden class=anchor aria-hidden=true href=#paralléliser>#</a></h2><p>On l&rsquo;a vu plus haut - en plus du chargement à la demande - beaucoup de composants facilitent la parallélisation des actions et font ainsi gagner en efficacité.</p><p>De son côté systemd se base sur son modèle de dépendances et cherche à minimiser les points de synchronisations qui ralentissent le démarrage.</p><p>Pour cela il va construire un arbre de dépendances pour pouvoir lancer un maximum de services en parallèle en ayant à attendre uniquement ceux qui lui sont nécessaires.</p><p>Pour arriver à cela des ordonnancements - souvent implicites - sont mis en place suivant différents critères afin de garantir la bonne cohérence des actions (c&rsquo;est d&rsquo;ailleurs souvent la partie la plus complexe à mettre en œuvre à mon avis).</p><p>Pour illustrer mes propos voici le graphique de démarrage, pour atteindre la <code>default.target</code> :</p><figure><a href=Systemd-bootup.png><img sizes="(min-width: 35em) 1200px, 100vw" srcset='https://cyrillesondag.github.io/blog/systemd-part-three/Systemd-bootup_hu_e1a0b70f98cb17c.png 480w,
https://cyrillesondag.github.io/blog/systemd-part-three/Systemd-bootup_hu_e65cd91ce5802fa9.png 800w,
https://cyrillesondag.github.io/blog/systemd-part-three/Systemd-bootup_hu_a4c3be56353fa715.png 1200w,
https://cyrillesondag.github.io/blog/systemd-part-three/Systemd-bootup_hu_f59d50a9e28df50f.png 1500w,' src=https://cyrillesondag.github.io/blog/systemd-part-three/Systemd-bootup_hu_e65cd91ce5802fa9.png alt="Bootup graph"></a><figcaption style=font-size:80%;text-align:center><p>Bootup graph</p></figcaption></figure><p>À noter quelques points qui me semblent importants :</p><ul><li>Lorsque systemd active un nombre de <em>unit</em> - et si aucun ordre n&rsquo;est spécifié - elles sont faites en parallèle.</li><li>Par défaut les services s&rsquo;exécutent après la <code>sysinit.target</code> (ou à la <code>basic.target</code> en mode user). Pour passer outre il faut ajouter la propriété <code>DefaultDependencies=false</code>.</li></ul><p>Comme souvent des outils sont mis à disposition pour nous aider :
On peut citer <code>systemd-analyse plot</code> (en SVG) ou <code>systemd-analyse dot</code> (au format DOT) qui permettent de générer des représentations graphiques de ce que nous venons d&rsquo;aborder.</p><h2 id=lutilisation-des-cgroups>L&rsquo;utilisation des cgroups<a hidden class=anchor aria-hidden=true href=#lutilisation-des-cgroups>#</a></h2><p>Contrairement à ce que l&rsquo;on pourrait croire le cgroups ne sont pas utilisés (du moins au départ) dans systemd pour le contrôle de resources, mais pour le contrôle des processus.</p><p>Il s&rsquo;avère en pratique compliqué de terminer correctement un service ayant un nombre de processus forkés important.</p><p>Pour tenter de comprendre le problème, revenons sur quelques notions UNIX :</p><p>Un processus est rattaché à une session.
Par convention le <code>SID</code> il est égal au <code>PID</code> du premier membre de la session, le &ldquo;session leader&rdquo;.
La session peut être un terminal, une connexion ssh&mldr; ou autre.</p><p>Dans une session on trouve un certain nombre de groupes de processus.
Le <code>PGID</code> est égal au <code>PID</code> du premier membre du groupe le &ldquo;process group leader&rdquo; (vous voyez la logique).
Au sein d&rsquo;une session un seul groupe peut être au premier plan.</p><p>Un processus PID a (presque) toujours un parent et hérite de certains de ses attributs (UID, GID, SID, PGID&mldr;).
Il est lui-même composé de plusieurs threads.</p><p>Si en théorie c&rsquo;est simple, en pratique, c&rsquo;est assez compliqué : liberté d&rsquo;implémentation, différences entre les systèmes UNIX, manque de syscall&mldr;
Tout cela a fait qu&rsquo;il est difficile de suivre correctement l&rsquo;ensemble des processus issus de différents forks.</p><p>Par exemple l&rsquo;une des techniques couramment utilisées pour lancer un processus en arrière-plan (daemon) est la technique dite du &ldquo;double-fork&rdquo;.
Elle consiste à effectuer les opérations suivantes :</p><ul><li>Un premier <code>fork()</code> pour créer un processus enfant de façon classique.</li><li>Qui va ensuite appeler <code>setsid(0)</code> pour se détacher de la session courante.</li><li>Pour enfin effectuer un nouveau <code>fork()</code> pour que ce changement soit pris en compte. Le processus nouvellement créé est ainsi rendu orphelin et ne peut plus interagir avec la session d&rsquo;origine (et vice versa).</li></ul><p>Du point de vue d&rsquo;un init manager, le problème est qu&rsquo;il n&rsquo;a connaissance que du PID issu du retour du premier fork, et pas de celui issu du second et éventuellement des autres processus forkés.</p><p>Une parade consistait à stocker le résultat du second fork dans un fichier PID file pour pouvoir le retrouver.
Cette méthode est tout à fait valide, mais souffre de limites en cas de nouveau fork et est de plus très dépendante de l&rsquo;implémentation qui en est faite.</p><p>On peut me faire remarquer que systemd utilise aussi des pid file, oui mais :</p><ul><li>c&rsquo;est surtout pour assurer la rétrocompatibilité avec les anciens scripts.</li><li>ce n&rsquo;est pas exactement utilisé pour la même fonction (principalement par le watchdog).</li></ul><p>Pour pallier ce problème, systemd utilise les <em>CGroup</em>.</p><p>Présent depuis longtemps dans le kernel Linux les <em>CGroups</em> sont prévus pour régler ce type de problème.
À la différence d&rsquo;autres propriétés un processus ne peut pas s&rsquo;échapper d&rsquo;un <em>CGroup</em> (à moins de créer un nouveau sous <em>CGroup</em> qui reste néanmoins toujours le descendant du parent).
Il est de plus assez aisé de recenser l&rsquo;ensemble des processus d&rsquo;un CGroup.</p><p>Systemd a donc décidé de lancer tous les services dans leurs propres CGroup, cela permet de résoudre une bonne fois pour toutes les problèmes d&rsquo;échappement des processus.</p><p>Et encore une fois fournit un outil pour nous aider :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>systemd-cgls
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://cyrillesondag.github.io/tags/linux/>Linux</a></li><li><a href=https://cyrillesondag.github.io/tags/systemd/>Systemd</a></li></ul><nav class=paginav><a class=prev href=https://cyrillesondag.github.io/blog/ansible-molecule/><span class=title>« Prev</span><br><span>Ansible Molecule</span>
</a><a class=next href=https://cyrillesondag.github.io/blog/systemd-part-two/><span class=title>Next »</span><br><span>Systemd - partie 2</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 3 on x" href="https://x.com/intent/tweet/?text=Systemd%20-%20partie%203&amp;url=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-three%2f&amp;hashtags=linux%2csystemd"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 3 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-three%2f&amp;title=Systemd%20-%20partie%203&amp;summary=Systemd%20-%20partie%203&amp;source=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-three%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-three%2f&title=Systemd%20-%20partie%203"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-three%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 3 on whatsapp" href="https://api.whatsapp.com/send?text=Systemd%20-%20partie%203%20-%20https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-three%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 3 on telegram" href="https://telegram.me/share/url?text=Systemd%20-%20partie%203&amp;url=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-three%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Systemd - partie 3 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Systemd%20-%20partie%203&u=https%3a%2f%2fcyrillesondag.github.io%2fblog%2fsystemd-part-three%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>© {year}</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>